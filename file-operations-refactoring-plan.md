# Анализ модулей с файловыми операциями и план рефакторинга

## Обзор

Данный документ содержит анализ модулей проекта benadis-runner, которые используют прямые файловые операции, и план их рефакторинга для использования пакета `internal/entity/filer`.

## Найденные модули с файловыми операциями

### 1. internal/app/app.go

**Местоположение:** `/root/r/benadis-runner/internal/app/app.go`

**Найденные файловые операции:**
- `os.MkdirTemp()` в функции `Convert()` (строка 59)

**Текущий код:**
```go
// Создаем временную директорию
cfg.RepPath, err = os.MkdirTemp(cfg.WorkDir, "s")
if err != nil {
    l.Error("Ошибка создания временной директории",
        slog.String("Описание ошибки", err.Error()),
    )
    return err
}
```

**Описание использования:**
Функция `Convert()` создает временную директорию для клонирования репозитория и выполнения конвертации проекта 1C:Enterprise.

### 2. scripts/install-dev-tools-no-sudo.sh

**Местоположение:** `/root/r/benadis-runner/scripts/install-dev-tools-no-sudo.sh`

**Найденные файловые операции:**
- `mktemp -d` для создания временной директории
- `rm -rf` для удаления файлов и директорий

**Примечание:** Данный файл является shell-скриптом и не требует рефакторинга в рамках Go-кода.

## План рефакторинга

### Этап 1: Рефакторинг internal/app/app.go

#### 1.1 Добавление зависимости от filer

**Действие:** Добавить импорт пакета filer и модифицировать функцию `Convert()` для использования файловой системы через интерфейс.

**Изменения в импортах:**
```go
import (
    // ... существующие импорты
    "github.com/Kargones/apk-ci/internal/entity/filer"
)
```

#### 1.2 Модификация функции Convert()

**Текущая реализация:**
```go
cfg.RepPath, err = os.MkdirTemp(cfg.WorkDir, "s")
```

**Новая реализация:**
```go
// Создаем файловую систему
fsConfig := filer.Config{
    Type:     filer.DiskFS,
    BasePath: cfg.WorkDir,
}
fs, err := filer.NewDiskFileSystem(fsConfig)
if err != nil {
    l.Error("Ошибка создания файловой системы",
        slog.String("Описание ошибки", err.Error()),
    )
    return err
}

// Создаем временную директорию
tempDir, err := fs.MkdirTemp(".", "s")
if err != nil {
    l.Error("Ошибка создания временной директории",
        slog.String("Описание ошибки", err.Error()),
    )
    return err
}

// Получаем полный путь для cfg.RepPath
cfg.RepPath = filepath.Join(cfg.WorkDir, tempDir)
```

#### 1.3 Инициализация и очистка файловой системы

**Рекомендации:**
1. Создать файловую систему в начале функции `Convert()`
2. Добавить defer для очистки временных файлов:
```go
defer func() {
    if tempDir != "" {
        if err := fs.RemoveAll(tempDir); err != nil {
            l.Warn("Ошибка очистки временной директории",
                slog.String("path", tempDir),
                slog.String("error", err.Error()),
            )
        }
    }
}()
```

### Этап 2: Дополнительные улучшения

#### 2.1 Создание фабрики файловых систем

**Предложение:** Создать вспомогательную функцию для инициализации файловой системы:

```go
// createFileSystem создает и настраивает файловую систему для работы приложения
func createFileSystem(workDir string) (filer.FileSystem, error) {
    config := filer.Config{
        Type:     filer.DiskFS,
        BasePath: workDir,
    }
    return filer.NewDiskFileSystem(config)
}
```

#### 2.2 Интеграция с конфигурацией

**Предложение:** Добавить в структуру `config.Config` поле для типа файловой системы:

```go
type Config struct {
    // ... существующие поля
    FileSystemType filer.FSType `yaml:"filesystem_type" default:"disk"`
}
```

### Этап 3: Тестирование

#### 3.1 Модульные тесты

**Действия:**
1. Создать тесты для модифицированной функции `Convert()`
2. Использовать `filer.MemoryFS` для тестирования без создания реальных файлов
3. Проверить корректность создания и очистки временных директорий

**Пример теста:**
```go
func TestConvert_WithMemoryFS(t *testing.T) {
    // Создаем in-memory файловую систему для тестирования
    cfg := &config.Config{
        WorkDir: "/tmp",
        // ... другие поля
    }
    
    ctx := context.Background()
    logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
    
    err := Convert(&ctx, logger, cfg)
    // Проверки...
}
```

#### 3.2 Интеграционные тесты

**Действия:**
1. Проверить работу с реальной файловой системой
2. Убедиться в корректности очистки временных файлов
3. Проверить совместимость с существующим функционалом Git

## Преимущества рефакторинга

### 1. Абстракция файловых операций
- Единый интерфейс для всех файловых операций
- Возможность легкого переключения между типами файловых систем
- Улучшенная тестируемость кода

### 2. Управление ресурсами
- Централизованное управление временными файлами
- Автоматическая очистка ресурсов
- Предотвращение утечек файловых дескрипторов

### 3. Безопасность
- Валидация путей файлов
- Предотвращение path traversal атак
- Контролируемый доступ к файловой системе

### 4. Тестируемость
- Возможность использования in-memory файловой системы в тестах
- Изоляция тестов от реальной файловой системы
- Более быстрое выполнение тестов

## Заключение

Рефакторинг модуля `internal/app/app.go` для использования пакета `internal/entity/filer` является относительно простой задачей, которая принесет значительные преимущества в плане архитектуры, тестируемости и безопасности кода.

Основные изменения затрагивают только одну функцию `Convert()`, что минимизирует риски и упрощает процесс внедрения.

Рекомендуется выполнить рефакторинг поэтапно с тщательным тестированием каждого этапа.