# Отчет об анализе тестовых файлов и план рефакторинга

## Обзор текущих тестов

- Основные директории с тестами:
  - `cmd/apk-ci/main_test.go` — интеграционные и smoke-тесты точки входа.
  - `internal/app/app_test.go` — тесты инициализации и интеграции приложения.
  - `internal/config/config_test.go` — большой набор unit-тестов конфигов и парсеров YAML/ENV.
  - `internal/service/sonarqube/service_test.go`, `internal/service/sonarqube/scanner_test.go` — сервисный слой и обертка сканера.
  - `internal/entity/filer/*_test.go` — утилиты работы с путями, файловой системой и edge-cases.
  - `internal/entity/one/convert/convert_test.go` — тесты конвертации/интеграции с 1С.
  - Дополнительно присутствует файл `internal/service/sonarqube/testing.go` с функциями `Test*`, однако его имя не оканчивается на `_test.go`, поэтому эти тесты не исполняются `go test` (это плейсхолдеры, их следует перенести или удалить).

## Сводка покрытия (по `coverage.out`)

- Общий уровень покрытия: ~57.2% (по выводу `go tool cover -func=coverage.out`).
- Наблюдения по отдельным участкам (из выдержек вывода):
  - `internal/util/runner/RunCommand` — ~83.3%.
  - `internal/util/runner/DisplayConfig` — 0% (нет тестов, легко покрывается через перехват вывода).
  - `internal/util/template_processor` — `ProcessMultipleTemplates` 100%, `ProcessWorkflowTemplate` ~92.3%.
  - `internal/servicemode/servicemode.go` — отдельные методы ~90.9%.
  - `test/retry_logic_demo.go` — 0% (демо-код, не критично).

Вывод: покрытие концентрируется вокруг `config`, `filer`, части `service`; при этом остаются лакуны в `util` (вывод/демонстрация), а также сложная логика `entity/sonarqube` (обработка ошибок, BSL-предобработка) покрыта фрагментарно.

## Дублирование и анти‑паттерны

- Повторяющиеся хелперы в тестах:
  - Инициализация `slog.Logger` с однотипными настройками в разных пакетах.
  - Подготовка минимальной конфигурации (`Config`) и окружения (`env`) вручную в нескольких местах, хотя в `cmd/main_test.go` уже есть `setupMinimalValidEnv`.
  - Создание/очистка временных директорий и файлов (часто вручную вместо `t.TempDir`).

- Дублирующиеся кейсы для `PathUtils`:
  - `utils_test.go`, `utils_coverage_test.go`, `path_utils_edge_cases_test.go`, `path_utils_additional_test.go` содержат пересекающиеся сценарии для `NormalizePath`, `ValidatePath`, `IsSubPath`, `GetFileExtension`. Кейсы можно объединить под один источник данных (таблицы) и уменьшить количество однотипных файлов.

- Неисполняемые плейсхолдеры:
  - `internal/service/sonarqube/testing.go` содержит функции `Test*`, но файл не `_test.go`, поэтому `go test` их не запускает. Это создает ложное ощущение покрытия.

- Недостатки изоляции:
  - Тесты сервисного слоя и сканера SonarQube не всегда используют явные заглушки/моки для внешних взаимодействий (команды, файловая система), из-за чего тесты либо упрощены до плейсхолдеров, либо уязвимы к окружению.

## План рефакторинга (уменьшение дублирования, рост покрытия)

1) Инфраструктура тестов: общий пакет `internal/testutil`
   - `NewTestLogger(level slog.Level) *slog.Logger` — единообразный «тихий» логгер (например, на `io.Discard`).
   - `BuildTestConfig(opts ...Option) *config.Config` — фабрика минимально валидной конфигурации с опциями.
   - `WithEnv(vars map[string]string, t *testing.T) (restore func())` — безопасная установка/восстановление ENV в тестах.
   - `CaptureOutput(fn func()) (stdout string)` — перехват stdout/stderr для тестов печати.
   - `TempDirFS(t *testing.T) (root string)` — унифицированное получение временного каталога через `t.TempDir`.

   Эффект: уменьшение boilerplate кода в тестах `cmd`, `app`, `service`, `filer`, ускорение добавления новых тестов.

2) Консолидация тестов PathUtils (filer)
   - Объединить пересекающиеся сценарии `NormalizePath`, `ValidatePath`, `IsSubPath`, `GetFileExtension` в 1–2 `_test.go` файла с хорошо структурированными таблицами кейсов.
   - Выделить общие таблицы или генераторы кейсов, чтобы исключить дубли по файлам.

3) Файловые операции и очистка
   - Везде заменить ручное создание/удаление директорий на `t.TempDir()` и работу с относительными путями внутри него.
   - Внести хелпер для частых операций (создание вложенных директорий, заполнение файла, проверка `Stat`).

4) Покрытие утилит и вывода
   - Добавить тест для `internal/util/runner/DisplayConfig` с использованием `CaptureOutput`.
   - Расширить кейсы для `RunCommand` (успех/неуспех, таймауты, корректная обработка stderr).
   - Завершить покрытие `internal/util/template_processor` по оставшимся веткам (ошибочные шаблоны, пустые входные данные).

5) SonarScanner: тестируемость и покрытие
   - В `internal/entity/sonarqube/scanner.go` ввести тонкую точку расширения (интерфейс для запуска команд/контекста), чтобы можно было замокать таймауты, коды выхода и вывод.
   - Написать unit‑тесты для чистых функций/методов:
     - `analyzeErrorOutput`, `getExitCodeMessage` — разбор и категоризация ошибок по коду выхода.
     - `ExtractProblematicBSLFiles`, `SuggestBSLExclusions` — извлечение путей и генерация исключений.
     - `validateBSLFile`, `FindAndValidateBSLFiles`, `preProcessBSLFiles` — проверка/фиксация BSL с использованием `t.TempDir` и синтетических файлов (есть `test_bsl_file.bsl` как источник проблем).

6) Конфигурация: golden‑тесты
   - Для `internal/config` добавить набор golden‑файлов YAML/ENV с типовыми конфигурациями, валидными и ошибочными, чтобы упростить добавление кейсов без дублирования кода парсинга.

7) Плейсхолдеры в `internal/service/sonarqube/testing.go`
   - Перенести содержимое в `*_test.go` (либо удалить как шум) и заменить на реальные тесты, используя `testutil` и моки.

8) Стандартизация стиля тестов
   - Единообразные таблицы (`name`, `input`, `expected`, `wantErr`).
   - Широкое применение `require` для preconditions и `assert` для проверок.
   - Единая схема именования субтестов (`t.Run(tt.name, ...)`).

## Оценка эффекта

- Снижение дублирования: за счет `internal/testutil` и консолидации PathUtils — уменьшение числа однотипных хелперов и тест‑файлов на 30–50%.
- Рост покрытия:
  - `internal/util/runner/DisplayConfig` → 80–100%.
  - `internal/util/template_processor` → до 100% по основным веткам.
  - `internal/entity/sonarqube` (чистые методы) → +20–30% относительно текущего уровня внутри модуля.
  - Общий таргет: 57% → 70–75% без рисков для стабильности.

## Порядок работ (итерации)

1) Внести `internal/testutil` и перевести 2–3 файла на использование хелперов (быстрый выигрыш, проверка удобства).
2) Консолидировать `PathUtils` тесты в `filer` пакете.
3) Добавить покрытие `DisplayConfig` и добить ветки в `template_processor`.
4) Ввести seam/интерфейс для `scanner.go` и покрыть чистые методы.
5) Реализовать golden‑тесты для `config` (без изменения публичных API).
6) Убрать плейсхолдеры `testing.go` или перенести их в валидные `*_test.go` и заменить реальными тестами.

## Примечания

- Избегаем изменения боевой логики без необходимости; интерфейсы вводим минимально и целевым образом для повышения тестируемости.
- Новые тесты не должны зависеть от внешних сервисов (SonarQube, Gitea); используем моки и временные каталоги.
- Сохраняем стиль проекта: таблицы кейсов, `assert/require`, русскоязычные описания там, где уже используются.


## 1. Введение

В рамках данного анализа была проведена оценка структуры тестовых файлов проекта apk-ci с целью выявления дублирования кода и определения возможностей для улучшения покрытия модулей.

## 2. Обзор структуры тестовых файлов

Проект содержит 76 тестовых файлов в различных модулях:

### Основные модули с тестами:
- `internal/app/` - тесты приложения (app_test.go - 1155 строк)
- `internal/config/` - тесты конфигурации (config_test.go - 1603 строки)
- `internal/git/` - тесты работы с Git (git_test.go - 1118 строк)
- `cmd/apk-ci/` - тесты основной команды (main_test.go - 1117 строк)
- `internal/entity/gitea/` - тесты Gitea API (gitea_test.go - 775 строк)
- `internal/servicemode/` - тесты сервисного режима (servicemode_test.go - 936 строк)
- `internal/rac/` - тесты RAC клиента (rac_test.go - 1260 строк)
- `internal/entity/one/convert/` - тесты конвертации (convert_test.go - 712 строк)
- `internal/constants/` - тесты констант (constants_test.go - 330 строк)

## 3. Выявленные проблемы

### 3.1 Значительное дублирование кода

#### 3.1.1 Дублирование создания логгеров
В большинстве тестовых файлов повторяется один и тот же код:

```go
logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))
```

Эта проблема обнаружена в файлах:
- internal/app/app_test.go
- internal/config/config_test.go
- internal/git/git_test.go
- internal/rac/rac_test.go
- internal/servicemode/servicemode_test.go

#### 3.1.2 Дублирование создания временных директорий
В тестах Git повторяется код:

```go
tempDir, err := os.MkdirTemp("", "git-test-*")
if err != nil {
    t.Fatalf("Не удалось создать временную директорию: %v", err)
}
defer func() {
    if err := os.RemoveAll(tempDir); err != nil {
        t.Logf("Failed to remove temp dir: %v", err)
    }
}()
```

#### 3.1.3 Дублирование создания HTTP тестовых серверов
В тестах Gitea повторяется код:

```go
server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    // обработчик запроса
}))
defer server.Close()
```

#### 3.1.4 Дублирование создания тестовых конфигураций
В多个 тестовых файлах повторяется код для создания тестовых конфигураций с похожими структурами.

### 3.2 Непоследовательные подходы к тестированию

#### 3.2.1 Разные подходы к мокированию
- В internal/entity/gitea/gitea_test.go используются httptest.NewServer
- В internal/servicemode/servicemode_test.go создаются Mock-структуры вручную

#### 3.2.2 Несогласованное использование assert-библиотек
- Некоторые тесты используют стандартный пакет testing
- Другие используют testify/assert

#### 3.2.3 Разные стили организации тестов
- Табличные тесты в некоторых файлах
- Отдельные функции для каждого тестового случая в других

### 3.3 Избыточные тесты

Некоторые тесты дублируют функциональность в разных файлах:
- Тесты с похожими названиями проверяют одни и те же сценарии
- Повторяющиеся проверки в разных модулях

### 3.4 Отсутствие общих утилит для тестирования

- Нет централизованного пакета для тестовых утилит
- Отсутствие общих функций для создания моков
- Нет стандартизированных тестовых данных

## 4. Анализ покрытия модулей

### 4.1 Хорошо покрытые модули:
- `internal/constants/` - полное покрытие констант
- `internal/entity/filer/` - множество тестов для файловой системы
- `internal/entity/sonarqube/` - хорошее покрытие SonarQube функциональности

### 4.2 Модули требующие улучшения покрытия:
- `internal/service/` - недостаточно интеграционных тестов
- `internal/util/` - не все утилиты имеют тесты
- `internal/logging/` - базовые тесты только для основных функций

## 5. План рефакторинга

### Этап 1: Создание общих тестовых утилит

1. **Создать пакет `internal/testing`** с общими утилитами:
   - Функция `CreateTestLogger(level slog.Level) *slog.Logger`
   - Функция `CreateTempDir(t *testing.T, prefix string) string` с автоматической очисткой
   - Функция `CreateTestHTTPServer(handler http.HandlerFunc) *httptest.Server`
   - Фабрики для создания тестовых конфигураций

2. **Создать общие мок-объекты**:
   - Базовый MockLogger для всех тестов
   - Унифицированный подход к созданию HTTP моков
   - Общие структуры для тестовых данных

### Этап 2: Рефакторинг тестов конфигурации

1. **Вынести повторяющийся код** в internal/config/config_test.go в общие функции
2. **Создать фабрики** для тестовых конфигураций:
   - `CreateTestAppConfig() *config.AppConfig`
   - `CreateTestSecretConfig() *config.SecretConfig`
   - `CreateTestDbConfig() map[string]*config.DatabaseInfo`
3. **Унифицировать подход** к мокированию внешних API

### Этап 3: Рефакторинг тестов Git

1. **Объединить дублирующийся код** для работы с временными директориями
2. **Создать общие тестовые сценарии** для различных операций Git
3. **Внедрить параметризованные тесты** для проверки разных сценариев

### Этап 4: Рефакторинг тестов Gitea

1. **Унифицировать создание HTTP тестовых серверов**
2. **Вынести общие проверки** в отдельные функции
3. **Создать общие тестовые данные** для API ответов

### Этап 5: Улучшение покрытия

1. **Добавить тесты для непокрытых веток кода**:
   - Пограничные случаи в функциях обработки ошибок
   - Тесты для негативных сценариев
   - Тесты для конкурентного доступа

2. **Создать интеграционные тесты** для проверки взаимодействия компонентов:
   - Тесты взаимодействия Git и Gitea
   - Тесты работы с конфигурациями
   - Тесты энд-ту-энд сценариев

3. **Добавить тесты для непокрытых утилит**:
   - Функции из internal/util/
   - Вспомогательные функции из различных модулей

### Этап 6: Оптимизация структуры тестов

1. **Сгруппировать тесты** по функциональности:
   - Юнит-тесты для отдельных функций
   - Интеграционные тесты для взаимодействия компонентов
   - Энд-ту-энд тесты для полных сценариев

2. **Унифицировать структуру** тестовых файлов:
   - Общий формат именования тестов
   - Стандартизированная структура тестовых функций
   - Единый подход к организации табличных тестов

3. **Добавить документацию** к сложным тестам:
   - Описание тестируемых сценариев
   - Пояснения к сложным мокам
   - Документация по тестовым данным

## 6. Приоритеты рефакторинга

### Высокий приоритет:
1. Создание пакета internal/testing с общими утилитами
2. Рефакторинг тестов конфигурации (самый большой файл)
3. Унификация подходов к мокированию

### Средний приоритет:
1. Рефакторинг тестов Git
2. Улучшение покрытия модулей service и util
3. Создание интеграционных тестов

### Низкий приоритет:
1. Оптимизация структуры тестов
2. Добавление документации
3. Рефакторинг небольших тестовых файлов

## 7. Ожидаемые результаты

1. **Сокращение дублирования кода** на 40-60%
2. **Улучшение читаемости** и поддерживаемости тестов
3. **Увеличение покрытия** кода тестами на 20-30%
4. **Стандартизация подходов** к тестированию в проекте
5. **Ускорение написания** новых тестов за счет переиспользуемых утилит

## 8. Рекомендации по реализации

1. **Постепенный рефакторинг**: выполнять изменения поэтапно, начиная с наиболее дублируемого кода
2. **Сохранение функциональности**: на каждом этапе убедиться, что все тесты продолжают работать
3. **Регрессионное тестирование**: после каждого этапа рефакторинга запускать полный набор тестов
4. **Документирование**: фиксировать изменения в документации проекта
5. **Обучение команды**: провести обучение по новым паттернам тестирования

## 9. Заключение

Проведенный анализ выявил значительные возможности для улучшения тестовой структуры проекта. Предложенный план рефакторинга позволит значительно сократить дублирование кода, улучшить покрытие тестами и стандартизировать подходы к тестированию в проекте.