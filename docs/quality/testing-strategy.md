# Стратегия тестирования и критерии приемки

## Уровни тестирования

- Юнит-тесты
  - Цель: проверка логики отдельных сервисов и провайдеров.
  - Инструменты: стандартный `testing`, моки узких интерфейсов (`PRReader`, `ProjectsAPI` и т.д.).

- Интеграционные тесты
  - Цель: проверка совместной работы сервисов SonarQube и Gitea, включая командный обработчик.
  - Сценарии: `AnalyzeProject`, `SQScanBranch`, `SQScanPR`, `SQReportBranch`.

- E2E (опционально)
  - CLI запускает сценарии на тестовом репозитории, проверка конечного результата (отчёты, комментарии в PR).

## Критерии приемки по этапам

- Этап 1 (DI/Providers)
  - Юнит-тесты провайдеров проходят, интеграционные тесты команд без регрессий.
  - Возможность подмены клиентов на моки через интерфейсы.

- Этап 2 (Segregation)
  - Сервисы зависят только от узких интерфейсов.
  - Моки просты, тесты покрывают сценарии без лишней реализации.

- Этап 3 (Logging)
  - Подмена логгера возможна без каскадных изменений.
  - Логирование содержит корреляционные идентификаторы.

- Этап 4 (SRP в app)
  - Политики и инфраструктура протестированы отдельно.
  - Интеграционные тесты команд проходят.

- Этап 5 (Command Registry)
  - Добавление новой команды — только регистрация.
  - Существующие команды работают без изменений.

## План отката изменений

- DI/Providers: оставить старые фабрики и переключение через конфиг (`use_legacy_factories`).
- Segregation: фасадные интерфейсы-обёртки, старые контракты до завершения миграции.
- Logging: конструкторы принимают оба типа (интерфейс и `*slog.Logger`) в переходный период.
- SRP: старые функции остаются как обёртки.
- Registry: флаг компиляции, возвращение к `switch` по необходимости.

## Контроль качества

- Метрики: покрытие тестами ключевых пакетов, длительность интеграционных сценариев.
- Автоматизация: `make test`/`go test ./...`, запуск smoke-сценариев в CI.
- Статический анализ: `go vet`, линтер, контроль циклических зависимостей.