# Детализированный план рефакторинга для соответствия SOLID

Документ описывает приоритизацию, пошаговые изменения с минимальным риском и механизмы проверки.

## Приоритеты изменений

1) Высокий — DIP/ISP (влияют на расширяемость и тестируемость)
   - Ввести слой DI/Providers для Gitea и SonarQube клиентов.
   - Сегрегировать широкие интерфейсы на роли, завися от потребностей сервисов.

2) Средний — SRP
   - Разделить обязанности в `internal/app/app.go` на слои: окружение, домен, оркестрация.

3) Средний — LSP/DIP в логировании
   - Перевести сервисы на `logging.StructuredLogger` и адаптер к `slog`.

4) Низкий — OCP (реестр команд)
   - Ввести реестр обработчиков команд вместо `switch`.

## Этапы (с проверкой на каждом шаге)

Этап 1: Введение DI/Providers
- Создать пакет `internal/di` с провайдерами: `GiteaProvider`, `SonarQubeProvider`, `ScannerProvider`.
- Перенести `CreateGiteaAPI` из `config.go` в `di/gitea_provider.go`.
- Обновить `app/sonarqube_init.go` для получения зависимостей через провайдеры.
- Тесты: юнит-тесты провайдеров (моки), интеграционные тесты команд `SQScanBranch`, `SQScanPR`.
- Критерии приемки: команды запускаются и используют абстракции; моки легко внедряются.
- Откат: оставить `CreateGiteaAPI` в `config.go` и флаг конфигурации для старого пути.

Этап 2: Сегрегация интерфейсов API
- Разбить `gitea.APIInterface` на: `PRReader`, `RepoFiles`, `CommitHistory`, `BranchReader`, `RepoBatchWriter`, `TeamDirectory`.
- Разбить `sonarqube.APIInterface` на: `ProjectsAPI`, `AnalysesAPI`, `IssuesAPI`, `MetricsAPI`, `QualityProfilesAPI`, `QualityGatesAPI`, `RulesAPI`.
- Обновить сервисы в `internal/service/sonarqube` и `internal/service` (Gitea) для зависимостей от узких интерфейсов.
- Тесты: компиляция, обновление моков, точечные юнит-тесты на каждый сервис.
- Критерии приемки: зависимости сервисов строго соответствуют потребностям; компиляция без широких зависимостей.
- Откат: сохранить старые интерфейсы как фасад над новыми до завершения миграции.

Этап 3: Логирование через интерфейс
- Ввести `logging.StructuredLogger` как обязательную зависимость сервисов.
- Добавить адаптер `SlogAdapter` для `*slog.Logger`.
- Заменить поля `*slog.Logger` на интерфейс по всему `internal/service/*` и `internal/app/*`.
- Тесты: юнит-тесты адаптера и существующие тесты сервисов.
- Критерии приемки: моки логгера подменяются без каскадных правок.
- Откат: оставить двойное принятие логгера в конструкторах на переходный период.

Этап 4: SRP разукрупнение `app.go`
- Вынести подготовку окружения (клонирование, tmp dirs) в `internal/infrastructure/repo_env.go`.
- Вынести бизнес-решение «нужно ли сканировать» в `internal/domain/scan_policy.go`.
- Оставить orchestration в командном обработчике.
- Тесты: юнит-тесты политики и инфраструктуры; интеграционные на `SQScanBranch`.
- Критерии приемки: код читабелен, компоненты переиспользуемы.
- Откат: сохранить старые функции как обёртки, вызывающие новые компоненты.

Этап 5: Реестр команд (OCP)
- Создать `internal/app/commands/registry.go` с реестром и регистрацией обработчиков.
- Обновить `cmd/apk-ci/main.go` для использования реестра.
- Тесты: юнит-тесты регистрации и выполнения команд.
- Критерии приемки: добавление новой команды — без изменений существующего кода.
- Откат: оставить старый `switch` под флагом компиляции.

## Механизмы проверки

- Юнит-тесты: каждый сервис и провайдер; моки для узких интерфейсов.
- Интеграционные тесты: сценарии `SQScanBranch`, `SQScanPR`, `SQReportBranch`.
- Статический анализ: `go vet`, линтер, интерфейсные зависимости.
- Smoke: запуск CLI на тестовом репозитории.

## Риски и Mitigation

- Ломка интерфейсов: постепенная миграция через фасад.
- Регрессия команд: параллельная реализация старого и нового пути запуска.
- Логирование: адаптер, сохранение совместимости.