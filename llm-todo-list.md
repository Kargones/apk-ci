# ToDo List для LLM: Автоматическое достижение покрытия тестами 85%

## Этап 1: Подготовка и анализ (Недели 1-2)

### 1.1 Анализ кодовой базы
- [ ] Сканировать все Go файлы в проекте и создать инвентарь функций
- [ ] Проанализировать зависимости между модулями
- [ ] Выявить публичные и приватные функции в каждом модуле
- [ ] Определить сложность функций (количество путей выполнения)
- [ ] Создать карту покрытия по функциям с текущими показателями

### 1.2 Приоритизация модулей
- [ ] Ранжировать модули по критичности для бизнеса
- [ ] Оценить сложность тестирования каждого модуля
- [ ] Создать матрицу "важность vs сложность" для планирования
- [ ] Определить порядок обработки модулей (начать с высокого приоритета)

### 1.3 Настройка инфраструктуры
- [ ] Настроить автоматический запуск тестов в CI/CD
- [ ] Интегрировать инструменты измерения покрытия (go test -cover)
- [ ] Настроить отчеты о покрытии в pull requests
- [ ] Подготовить тестовые данные и mock объекты

## Этап 2: Настройка LLM для генерации тестов (Недели 3-4)

### 2.1 Выбор и настройка LLM
- [ ] Оценить доступные модели (GPT-4, Claude, Codex, местные модели)
- [ ] Настроить API доступ к выбранной модели
- [ ] Протестировать качество генерации на примерах
- [ ] Определить оптимальные параметры модели (temperature, max_tokens)

### 2.2 Создание системы промптов
- [ ] Разработать базовый промпт для генерации unit тестов
- [ ] Создать промпт для integration тестов
- [ ] Разработать промпт для тестирования edge cases
- [ ] Создать промпт для генерации mock объектов
- [ ] Разработать промпт для table-driven тестов
- [ ] Создать промпт для тестирования ошибок

### 2.3 Разработка инструментов автоматизации
- [ ] Создать CLI инструмент для генерации тестов
- [ ] Разработать парсер Go кода для извлечения функций
- [ ] Создать генератор контекста для LLM (сигнатуры функций, зависимости)
- [ ] Разработать валидатор сгенерированного кода
- [ ] Создать систему пакетной обработки файлов

## Этап 3: Генерация тестов для высокоприоритетных модулей (Недели 5-8)

### 3.1 internal/entity/one/convert (Цель: 8.5% → 85%)
- [ ] Проанализировать все функции конвертации данных
- [ ] Сгенерировать тесты для конвертации различных типов данных
- [ ] Создать тесты для обработки ошибок конвертации
- [ ] Разработать тесты производительности для больших объемов
- [ ] Добавить тесты для граничных случаев (nil, пустые значения)
- [ ] Создать integration тесты с реальными данными 1С

### 3.2 internal/service/sonarqube (Цель: 13.7% → 85%)
- [ ] Сгенерировать тесты для всех API методов
- [ ] Создать mock тесты для внешних HTTP вызовов
- [ ] Разработать тесты обработки различных ответов SonarQube
- [ ] Добавить тесты для обработки ошибок сети
- [ ] Создать тесты для парсинга результатов анализа
- [ ] Разработать integration тесты с тестовым SonarQube сервером

### 3.3 internal/entity/one/store (Цель: 23.0% → 85%)
- [ ] Сгенерировать тесты для всех операций с хранилищем
- [ ] Создать тесты для транзакций и консистентности данных
- [ ] Разработать тесты восстановления после сбоев
- [ ] Добавить тесты для concurrent доступа
- [ ] Создать тесты для различных типов хранилищ
- [ ] Разработать performance тесты для больших объемов данных

### 3.4 internal/entity/one/enterprise (Цель: 25.0% → 85%)
- [ ] Проанализировать корпоративные функции 1С
- [ ] Сгенерировать тесты для бизнес-логики
- [ ] Создать тесты для интеграции с корпоративными системами
- [ ] Разработать тесты для обработки лицензий и ограничений
- [ ] Добавить тесты для многопользовательских сценариев

### 3.5 internal/entity/gitea (Цель: 27.0% → 85%)
- [ ] Сгенерировать тесты для всех API методов Gitea
- [ ] Создать mock тесты для HTTP клиента
- [ ] Разработать тесты для аутентификации и авторизации
- [ ] Добавить тесты для работы с репозиториями
- [ ] Создать тесты для webhook обработки
- [ ] Разработать integration тесты с тестовым Gitea сервером

## Этап 4: Генерация тестов для среднеприоритетных модулей (Недели 9-12)

### 4.1 internal/entity/dbrestore (Цель: 31.7% → 85%)
- [ ] Сгенерировать тесты для операций восстановления БД
- [ ] Создать тесты для различных типов backup файлов
- [ ] Разработать тесты для проверки целостности данных
- [ ] Добавить тесты для обработки поврежденных backup'ов
- [ ] Создать performance тесты для больших БД

### 4.2 internal/servicemode (Цель: 34.7% → 85%)
- [ ] Проанализировать различные режимы работы сервиса
- [ ] Сгенерировать тесты для переключения между режимами
- [ ] Создать тесты для конфигурации каждого режима
- [ ] Разработать тесты для обработки ошибок в режимах
- [ ] Добавить integration тесты для полного жизненного цикла

### 4.3 internal/entity/sonarqube (Цель: 36.4% → 85%)
- [ ] Сгенерировать тесты для entity моделей SonarQube
- [ ] Создать тесты для сериализации/десериализации
- [ ] Разработать тесты для валидации данных
- [ ] Добавить тесты для маппинга между различными версиями API

### 4.4 internal/entity/one/edt (Цель: 38.5% → 85%)
- [ ] Проанализировать функции работы с EDT
- [ ] Сгенерировать тесты для парсинга EDT файлов
- [ ] Создать тесты для генерации EDT структур
- [ ] Разработать тесты для валидации EDT схем
- [ ] Добавить performance тесты для больших EDT файлов

### 4.5 internal/git (Цель: 39.9% → 85%)
- [ ] Сгенерировать тесты для всех Git операций
- [ ] Создать тесты для работы с различными типами репозиториев
- [ ] Разработать тесты для обработки конфликтов
- [ ] Добавить тесты для работы с ветками и тегами
- [ ] Создать integration тесты с реальными Git репозиториями

## Этап 5: Автоматическая валидация и корректировка (Недели 13-16)

### 5.1 Автоматическая валидация
- [ ] Запустить все сгенерированные тесты и проверить их прохождение
- [ ] Проанализировать покрытие кода после добавления тестов
- [ ] Выявить функции, которые все еще не покрыты тестами
- [ ] Проверить производительность тестов (время выполнения)
- [ ] Выявить flaky тесты и нестабильные сценарии

### 5.2 Автоматическая корректировка
- [ ] Исправить синтаксические ошибки в сгенерированных тестах
- [ ] Дополнить недостающие import'ы и зависимости
- [ ] Оптимизировать медленные тесты
- [ ] Исправить логические ошибки в тестовых сценариях
- [ ] Добавить недостающие mock объекты

### 5.3 Итеративное улучшение
- [ ] Повторно сгенерировать тесты для функций с низким покрытием
- [ ] Улучшить промпты на основе анализа качества тестов
- [ ] Добавить дополнительные edge cases
- [ ] Оптимизировать структуру тестов для лучшей читаемости

## Этап 6: Финальная оптимизация и достижение цели (Недели 17-20)

### 6.1 Анализ текущего покрытия
- [ ] Запустить полный анализ покрытия кода
- [ ] Выявить оставшиеся непокрытые функции
- [ ] Проанализировать причины низкого покрытия в отдельных модулях
- [ ] Создать план для достижения 85% в каждом модуле

### 6.2 Целевая генерация тестов
- [ ] Сгенерировать тесты специально для непокрытых функций
- [ ] Создать дополнительные integration тесты
- [ ] Разработать end-to-end тесты для критических сценариев
- [ ] Добавить stress тесты для производительности

### 6.3 Финальная валидация
- [ ] Запустить полный набор тестов
- [ ] Проверить достижение цели 85% покрытия
- [ ] Оптимизировать время выполнения тестов
- [ ] Убедиться в отсутствии flaky тестов
- [ ] Провести code review сгенерированных тестов


## Технические детали для LLM

### Промпты для генерации тестов

#### Базовый промпт для unit тестов:
```
Создай comprehensive unit тесты для следующей Go функции:

```go
{function_code}
```

Контекст:
- Пакет: {package_name}
- Зависимости: {dependencies}
- Используемые типы: {types}

Требования:
1. Покрой все возможные пути выполнения (100% branch coverage)
2. Включи тесты для всех граничных случаев
3. Добавь тесты для обработки ошибок
4. Используй table-driven тесты где применимо
5. Создай необходимые mock объекты
6. Следуй Go конвенциям тестирования
7. Добавь комментарии на русском языке
8. Убедись, что тесты независимы и детерминированы

Формат ответа: только Go код тестов без дополнительных объяснений.
```

#### Промпт для integration тестов:
```
Создай integration тесты для модуля {module_name} в Go проекте.

Модуль включает функции:
{functions_list}

Внешние зависимости:
{external_dependencies}

Требования:
1. Протестируй взаимодействие между функциями модуля
2. Создай тесты для интеграции с внешними сервисами (используй mock'и)
3. Добавь тесты для обработки ошибок интеграции
4. Включи тесты для различных конфигураций
5. Создай setup и teardown функции для тестов
6. Используй testify/suite для организации тестов
7. Добавь комментарии на русском языке

Формат ответа: только Go код тестов без дополнительных объяснений.
```

#### Промпт для mock объектов:
```
Создай mock объекты для следующих интерфейсов в Go:

{interfaces_code}

Требования:
1. Используй testify/mock или создай простые mock'и
2. Включи методы для настройки ожиданий
3. Добавь методы для проверки вызовов
4. Создай helper функции для создания mock'ов
5. Добавь примеры использования в комментариях
6. Следуй Go конвенциям именования
7. Комментарии на русском языке

Формат ответа: только Go код mock'ов без дополнительных объяснений.
```

### Автоматизация процесса

#### Скрипт для анализа покрытия:
```bash
#!/bin/bash
# analyze_coverage.sh

# Запуск тестов с покрытием
go test -coverprofile=coverage.out ./...

# Анализ покрытия по модулям
go tool cover -func=coverage.out | grep -E "(internal/|total:)" > coverage_report.txt

# Выявление функций без покрытия
go tool cover -func=coverage.out | grep "0.0%" > uncovered_functions.txt

# Генерация HTML отчета
go tool cover -html=coverage.out -o coverage.html

echo "Анализ покрытия завершен. Результаты в coverage_report.txt"
```

#### Скрипт для генерации тестов:
```bash
#!/bin/bash
# generate_tests.sh

MODULE_PATH=$1
TARGET_COVERAGE=${2:-85}

echo "Генерация тестов для модуля: $MODULE_PATH"
echo "Целевое покрытие: $TARGET_COVERAGE%"

# Анализ текущего покрытия
CURRENT_COVERAGE=$(go test -cover ./$MODULE_PATH | grep -o '[0-9.]\+%' | head -1 | sed 's/%//')

echo "Текущее покрытие: $CURRENT_COVERAGE%"

if (( $(echo "$CURRENT_COVERAGE < $TARGET_COVERAGE" | bc -l) )); then
    echo "Требуется генерация дополнительных тестов"
    
    # Извлечение функций без тестов
    go-ast-parser $MODULE_PATH > functions.json
    
    # Генерация тестов через LLM
    llm-test-generator --input functions.json --output ${MODULE_PATH}_test.go
    
    echo "Тесты сгенерированы в ${MODULE_PATH}_test.go"
else
    echo "Покрытие уже достигнуто"
fi
```

### Метрики для отслеживания прогресса

- **Общее покрытие проекта**: текущее значение / 85%
- **Покрытие по модулям**: индивидуальное отслеживание каждого модуля
- **Количество сгенерированных тестов**: общее количество и по модулям
- **Качество тестов**: процент прохождения, время выполнения
- **Производительность генерации**: время на генерацию тестов для одной функции

### Критерии завершения

- [ ] Общее покрытие проекта ≥ 85%
- [ ] Покрытие каждого модуля ≥ 80% (допустимо 5% отклонение для сложных модулей)
- [ ] Все тесты проходят успешно
- [ ] Время выполнения всех тестов ≤ 10 минут
- [ ] Отсутствие flaky тестов
- [ ] Настроен автоматический мониторинг покрытия
- [ ] Команда обучена работе с системой

---

**Общий прогресс**: 0/150+ задач выполнено  
**Ожидаемое время выполнения**: 20+ недель  
**Ответственный за выполнение**: LLM система + команда разработки  
**Дата создания плана**: 2025-01-16