# Подробный поэтапный план реализации архитектуры конфигурации

## Обзор

Данный документ содержит подробный план реализации новой архитектуры системы конфигурации для проекта benadis-runner, описанной в `docs/config-arch.md`.

## Анализ текущего состояния

### Существующие файлы конфигурации:
- `project.yaml` - конфигурация проекта (уже соответствует архитектуре)
- `dbconfig.yaml` - конфигурация баз данных (уже соответствует архитектуре)
- `sec.config.yaml` - частичная конфигурация секретов (только для dbrestore)

### Текущая структура Config в `internal/config/config.go`:
- Монолитная структура с множественными полями
- Загрузка через `cleanenv.ReadEnv()`
- Отсутствие разделения на логические группы
- Смешивание системных настроек, путей, пользователей и секретов

### Существующие модули с собственной конфигурацией:
- `ServiceModeConfig` - частично реализован
- `EdtConfig` - частично реализован
- Convert, DBRestore - имеют собственные системы загрузки

## Этапы реализации

### Этап 1: Создание новых структур конфигурации

#### 1.1 Создание файла app.yaml ✅ ВЫПОЛНЕНО
**Цель**: Выделить настройки приложения в отдельный файл

**Действия**:
1. ✅ Создать файл `app.yaml` в корне проекта
2. ✅ Перенести следующие настройки из текущей структуры Config:
   - `logLevel` (новое поле)
   - `workDir` (из WorkDir)
   - `tmpDir` (из TmpDir)
   - `timeout` (новое поле, по умолчанию 30s)
   - Секция `paths`:
     - `bin1cv8` (из Bin1cv8)
     - `binIbcmd` (из BinIbcmd)
     - `edtCli` (из EdtCli)
     - `rac` (новое поле)
   - Секция `rac`:
     - `port` (из RacPort)
     - `timeout` (из RacTimeout)
     - `retries` (из RacRetries)
   - Секция `users`:
     - `rac` (из RacUser)
     - `db` (из DbUser)
     - `mssql` (новое поле)
     - `storeAdmin` (новое поле)

**Пример содержимого app.yaml**:
```yaml
app:
  logLevel: "Debug"
  workDir: "/tmp/benadis"
  tmpDir: "/tmp/benadis/temp"
  timeout: 30

paths:
  bin1cv8: "/opt/1cv8/x86_64/8.3.27.1606/1cv8"
  binIbcmd: "/opt/1cv8/x86_64/8.3.27.1606/ibcmd"
  edtCli: "/opt/1C/1CE/components/1c-edt-2024.2.6+7-x86_64/1cedtcli"
  rac: "/opt/1cv8/x86_64/8.3.27.1606/rac"

rac:
  port: 1545
  timeout: 30
  retries: 3

users:
  rac: "admin"
  db: "db_user"
  mssql: "mssql_user"
  storeAdmin: "store_admin"
```

#### 1.2 Создание файла secret.yaml ✅ ВЫПОЛНЕНО
**Цель**: Централизовать все секреты в одном файле

**Действия**:
1. ✅ Создать файл `secret.yaml` в корне проекта
2. ✅ Перенести секреты из текущей структуры:
   - Пароли пользователей
   - Токены доступа
3. ✅ Расширить существующий `sec.config.yaml` или заменить его

**Пример содержимого secret.yaml**:
```yaml
passwords:
  rac: "secure_password"
  db: "db_password"
  mssql: "mssql_password"
  storeAdminPassword: "store_admin_password"

gitea:
  accessToken: "gitea_token_here"

# Секреты для dbrestore (из существующего sec.config.yaml)
dbrestore:
  password: "8kX8h!NNIbEbdu8o0"
```

#### 1.3 Обновление структур в config.go ✅ ВЫПОЛНЕНО
**Цель**: Создать новые структуры данных согласно архитектуре

**Действия**:
1. ✅ Добавить новые структуры в `internal/config/config.go`:
   - `AppConfig`
   - `ProjectConfig` (уже частично существует)
   - `SecretConfig`
   - `DatabaseInfo` (уже существует в dbconfig.yaml)

2. ✅ Обновить основную структуру `Config`:
```go
type Config struct {
    // Системные настройки
    Actor         string `env:"BR_ACTOR"`
    Env           string `env:"BR_ENV"`
    Command       string `env:"BR_COMMAND"`
    Logger        *slog.Logger
    
    // Пути к файлам конфигурации
    ConfigSystem  string `env:"BR_CONFIG_SYSTEM" env-default:"app.yaml"`
    ConfigProject string `env:"BR_CONFIG_PROJECT" env-default:"project.yaml"`
    ConfigSecret  string `env:"BR_CONFIG_SECRET" env-default:"secret.yaml"`
    
    // Настройки приложения (из app.yaml)
    AppConfig     *AppConfig
    
    // Настройки проекта (из project.yaml)
    ProjectConfig *ProjectConfig
    
    // Секреты (из secret.yaml)
    SecretConfig  *SecretConfig
    
    // Конфигурация баз данных
    DbConfig      map[string]*DatabaseInfo
    
    // Gitea настройки (для обратной совместимости)
    GiteaURL      string
    Owner         string
    Repo          string
    BaseBranch    string
    NewBranch     string
    ProxyURL      string
}
```

### Этап 2: Реализация загрузчиков конфигурации

#### 2.1 Создание функции LoadConfiguration ✅ ВЫПОЛНЕНО
**Цель**: Реализовать центральную функцию загрузки всех конфигураций

**Действия**:
1. ✅ Создать функцию `LoadConfiguration()` в `config.go`
2. ✅ Реализовать поэтапную загрузку:
   - Базовые настройки из переменных окружения
   - Конфигурация приложения из app.yaml
   - Конфигурация проекта из project.yaml
   - Секреты из secret.yaml
   - Конфигурация баз данных из dbconfig.yaml
   - Валидация конфигурации

#### 2.2 Реализация методов загрузки отдельных конфигураций ✅ ВЫПОЛНЕНО
**Цель**: Создать специализированные методы для каждого типа конфигурации

**Действия**:
1. ✅ `loadAppConfig()` - загрузка app.yaml
2. ✅ `loadProjectConfig()` - загрузка project.yaml
3. ✅ `loadSecretConfig()` - загрузка secret.yaml
4. ✅ `loadDbConfig()` - загрузка dbconfig.yaml
5. ⚠️ `getConfigData()` - универсальный метод получения данных (файл/API) - используется существующий GetConfigData

#### 2.3 Реализация методов получения информации о БД ✅ ВЫПОЛНЕНО
**Цель**: Создать удобные методы для работы с информацией о базах данных

**Действия**:
1. ✅ `GetOneServer(dbName string)` - получение сервера 1С
2. ✅ `GetRacServerForDb(dbName string)` - получение RAC сервера
3. ✅ `IsProductionDb(dbName string)` - проверка типа базы
4. ✅ `GetDbServer(dbName string)` - получение MS SQL сервера
5. ✅ `GetDatabaseInfo(dbName string)` - получение полной информации
6. ✅ `GetAllDatabases()` - получение списка всех БД
7. ✅ `GetProductionDatabases()` - получение списка продуктивных БД
8. ✅ `GetTestDatabases()` - получение списка тестовых БД

### Этап 3: Обновление существующих модулей

#### 3.1 Обновление ServiceModeConfig ✅ ВЫПОЛНЕНО
**Цель**: Адаптировать модуль к новой архитектуре

**Действия**:
1. ✅ Обновить структуру `ServiceModeConfig` в `config.go`:
```go
type ServiceModeConfig struct {
    RacPath             string        `yaml:"racPath" env:"SERVICE_RAC_PATH"`
    RacServer           string        `yaml:"racServer" env:"SERVICE_RAC_SERVER"`
    RacPort             int           `yaml:"racPort" env:"SERVICE_RAC_PORT"`
    RacUser             string        `yaml:"racUser" env:"SERVICE_RAC_USER"`
    RacPassword         string        `yaml:"racPassword" env:"SERVICE_RAC_PASSWORD"`
    DbUser              string        `yaml:"dbUser" env:"SERVICE_DB_USER"`
    DbPassword          string        `yaml:"dbPassword" env:"SERVICE_DB_PASSWORD"`
    MssqlUser           string        `yaml:"mssqlUser" env:"SERVICE_MSSQL_USER"`
    MssqlPassword       string        `yaml:"mssqlPassword" env:"SERVICE_MSSQL_PASSWORD"`
    StoreAdmin          string        `yaml:"storeAdmin" env:"SERVICE_STORE_ADMIN"`
    StoreAdminPassword  string        `yaml:"storeAdminPassword" env:"SERVICE_STORE_ADMIN_PASSWORD"`
    RacTimeout          time.Duration `yaml:"racTimeout" env:"SERVICE_RAC_TIMEOUT"`
    RacRetries          int           `yaml:"racRetries" env:"SERVICE_RAC_RETRIES"`
}
```

2. ✅ Обновить функцию `LoadServiceModeConfig(cfg *Config, dbName string)`:
   - Получение RAC сервера для конкретной базы из dbconfig.yaml
   - Загрузка пользователей из AppConfig
   - Загрузка паролей из SecretConfig
   - Переопределение из переменных окружения

3. ✅ Обновить `internal/servicemode/servicemode.go`:
   - Адаптировать к новой структуре конфигурации
   - Обновить функцию `LoadServiceModeConfig()`

#### 3.2 Обновление EdtConfig ✅ ВЫПОЛНЕНО
**Цель**: Адаптировать EDT модуль к новой архитектуре

**Действия**:
1. ✅ Обновить структуру `EdtConfig` в `config.go`
2. ✅ Обновить функцию `LoadEdtConfig(cfg *Config)`
3. ✅ Обновить `internal/entity/one/edt/edt.go`:
   - Заменить прямую загрузку конфигурации на использование централизованной системы
   - Обновить метод `InitWithEdtConfig()`

#### 3.3 Обновление Convert модуля ✅ ВЫПОЛНЕНО
**Цель**: Интегрировать Convert в централизованную систему конфигурации

**Действия**:
1. ✅ Создать структуру `ConvertConfig` в `config.go`
2. ✅ Создать функцию `LoadConvertConfig(cfg *Config)`
3. ⚠️ Обновить `internal/entity/one/convert/convert.go`:
   - Заменить метод `Load()` на использование централизованной конфигурации
   - Сохранить обратную совместимость

#### 3.4 Обновление DBRestore модуля ✅ ВЫПОЛНЕНО
**Цель**: Интегрировать DBRestore в централизованную систему конфигурации

**Действия**:
1. ✅ Создать структуру `DBRestoreConfig` в `config.go`
2. ✅ Создать функцию `LoadDBRestoreConfig(cfg *Config)`
3. ⚠️ Перенести настройки из `sec.config.yaml` в `secret.yaml`
4. ⚠️ Обновить `internal/entity/dbrestore/dbrestore.go`:
   - Заменить прямую загрузку YAML на использование централизованной конфигурации
   - Обновить метод `Init()`

### Этап 4: Обновление точек входа

#### 4.1 Обновление main.go
**Цель**: Адаптировать главную функцию к новой архитектуре

**Действия**:
1. Заменить `config.MustLoad()` на `config.LoadConfiguration()`
2. Удалить прямые вызовы `os.Getenv()`
3. Добавить поля в основную структуру Config:
   - `InfobaseName` из `BR_INFOBASE_NAME`
   - `TerminateSessions` из `BR_TERMINATE_SESSIONS`

#### 4.2 Обновление app.go
**Цель**: Адаптировать функции приложения к новой архитектуре

**Действия**:
1. Обновить функции, использующие конфигурацию
2. Заменить прямое обращение к полям Config на использование специализированных структур
3. Обновить функцию `Convertedt()` для использования `EdtConfig`

### Этап 5: Тестирование и валидация

#### 5.1 Создание тестов
**Цель**: Обеспечить корректность работы новой системы конфигурации

**Действия**:
1. Создать тесты для функций загрузки конфигурации
2. Создать тесты для методов получения информации о БД
3. Создать интеграционные тесты для модулей
4. Создать тесты для валидации конфигурации

#### 5.2 Создание примеров конфигурации
**Цель**: Предоставить примеры для разработчиков

**Действия**:
1. Создать примеры файлов конфигурации в папке `examples/`
2. Обновить документацию
3. Создать миграционные скрипты для перехода от старой конфигурации

### Этап 6: Миграция и обратная совместимость

#### 6.1 Реализация обратной совместимости
**Цель**: Обеспечить плавный переход на новую архитектуру

**Действия**:
1. Сохранить старые методы загрузки с пометкой `@deprecated`
2. Реализовать автоматическую миграцию настроек
3. Добавить предупреждения о использовании устаревших методов

#### 6.2 Создание миграционных инструментов
**Цель**: Автоматизировать процесс миграции

**Действия**:
1. Создать утилиту для конвертации существующих конфигураций
2. Создать валидатор конфигурации
3. Создать инструмент для проверки совместимости

### Этап 7: Документация и финализация

#### 7.1 Обновление документации
**Цель**: Предоставить полную документацию по новой архитектуре

**Действия**:
1. Обновить README.md
2. Создать руководство по миграции
3. Обновить примеры использования
4. Создать troubleshooting guide

#### 7.2 Очистка кода
**Цель**: Удалить устаревший код и оптимизировать структуру

**Действия**:
1. Удалить устаревшие методы и структуры
2. Оптимизировать импорты
3. Провести code review
4. Обновить версию приложения

## Приоритеты реализации

### Высокий приоритет (критично для работы):
1. Этап 1.3 - Обновление структур в config.go
2. Этап 2.1 - Создание функции LoadConfiguration
3. Этап 2.2 - Реализация методов загрузки
4. Этап 3.1 - Обновление ServiceModeConfig

### Средний приоритет (важно для архитектуры):
1. Этап 1.1 - Создание app.yaml
2. Этап 1.2 - Создание secret.yaml
3. Этап 2.3 - Методы получения информации о БД
4. Этап 3.2 - Обновление EdtConfig

### Низкий приоритет (улучшения):
1. Этап 3.3 - Обновление Convert модуля
2. Этап 3.4 - Обновление DBRestore модуля
3. Этап 5 - Тестирование
4. Этап 6 - Миграция
5. Этап 7 - Документация

## Риски и митигация

### Риск 1: Нарушение обратной совместимости
**Митигация**: 
- Поэтапная реализация с сохранением старых методов
- Тщательное тестирование на существующих конфигурациях
- Создание миграционных инструментов

### Риск 2: Сложность миграции для пользователей
**Митигация**:
- Автоматические инструменты миграции
- Подробная документация
- Примеры конфигураций

### Риск 3: Производительность загрузки конфигурации
**Митигация**:
- Кэширование загруженных конфигураций
- Ленивая загрузка неиспользуемых секций
- Оптимизация парсинга YAML

## Заключение

Данный план обеспечивает поэтапную реализацию новой архитектуры конфигурации с минимальными рисками для существующей функциональности. Ключевые преимущества новой архитектуры:

1. **Модульность** - четкое разделение типов конфигурации
2. **Безопасность** - централизованное управление секретами
3. **Гибкость** - поддержка различных источников конфигурации
4. **Масштабируемость** - простота добавления новых модулей
5. **Сопровождаемость** - улучшенная структура кода

Реализация должна проводиться итеративно с постоянным тестированием и валидацией на каждом этапе.