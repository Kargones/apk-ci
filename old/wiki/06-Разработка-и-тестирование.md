# Руководство по разработке и тестированию

Данный документ содержит инструкции по настройке среды разработки, соглашениям кодирования, процессам тестирования и внесению изменений в проект benadis-runner.

## Настройка среды разработки

### Требования к системе

#### Базовые требования
- **Go**: версия 1.24.3 или выше
- **Git**: для работы с версионированием
- **Make**: для автоматизации сборки
- **golangci-lint**: для проверки качества кода

#### Платформа 1С:Предприятие
- **1cv8**: основная платформа версии 8.3.25+ 
- **ibcmd**: утилита командной строки
- **rac**: консоль удаленного администрирования
- **1cedtcli**: EDT командная строка (опционально)

### Установка инструментов разработки

#### Установка Go
```bash
# Linux
wget https://go.dev/dl/go1.24.3.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf go1.24.3.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin

# Добавить в ~/.bashrc
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.bashrc
```

#### Установка golangci-lint
```bash
# Используйте скрипт из проекта (устанавливает версию с поддержкой конфигурационного формата версии 2)
./scripts/inst-golangci-lint.sh

# Для установки через дополнительный скрипт
./scripts/inst-golangci-lint-v2.sh

# Или установка вручную (установка golangci-lint v2)
go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2

# Для установки последней версии v1
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# Для установки определенной версии v1
go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.64.8
```

Примечание: "version: 2" в файле `.golangci.yml` относится к формату конфигурационного файла. Начиная с версии golangci-lint v2, конфигурационный формат version 2 поддерживается по умолчанию.

#### Установка дополнительных инструментов
```bash
# godoc для генерации документации
go install golang.org/x/tools/cmd/godoc@latest

# goimports для автоматического управления импортами
go install golang.org/x/tools/cmd/goimports@latest

# govulncheck для проверки уязвимостей
go install golang.org/x/vuln/cmd/govulncheck@latest
```

### Клонирование и настройка проекта

```bash
# Клонирование репозитория
git clone <repository-url>
cd benadis-runner

# Установка зависимостей
go mod download

# Настройка среды разработки
make setup-dev

# Проверка окружения
make check-env
```

### Структура проекта для разработчиков

```
github.com/Kargones/apk-ci/
├── cmd/                        # Точки входа приложения
│   └── github.com/Kargones/apk-ci/         # Основное приложение
├── internal/                   # Внутренние пакеты
│   ├── app/                    # Логика приложения
│   ├── config/                 # Управление конфигурацией
│   ├── entity/                 # Доменные сущности
│   │   ├── one/               # Интеграция с 1С
│   │   └── gitea/             # Интеграция с Gitea
│   ├── rac/                   # RAC операции
│   ├── service/               # Сервисный слой
│   └── util/                  # Утилиты
├── docs/                      # Документация
├── scripts/                   # Скрипты автоматизации
├── examples/                  # Примеры конфигурации
├── .github/workflows/         # CI/CD пайплайны
├── Makefile                   # Автоматизация сборки
├── go.mod                     # Зависимости Go
└── go.sum                     # Контрольные суммы
```

## Соглашения по кодированию

### Стандарты Go

Проект следует официальным соглашениям Go:

1. **Форматирование**: `go fmt`
2. **Импорты**: `goimports`
3. **Линтинг**: `golangci-lint`
4. **Vet проверки**: `go vet`

### Именование

#### Пакеты
```go
// ✅ Хорошо - короткие, описательные имена
package config
package rac
package store

// ❌ Плохо - длинные или общие имена
package configuration
package utils
package helpers
```

#### Переменные и функции
```go
// ✅ Хорошо - camelCase для локальных, PascalCase для экспортируемых
var infobaseName string
func GetClusterUUID() string

// ❌ Плохо - snake_case или неописательные имена
var infobase_name string
func GetUUID() string
```

#### Константы
```go
// ✅ Хорошо - группировка в блоки с описательными именами
const (
    ActServiceModeEnable  = "service-mode-enable"
    ActServiceModeDisable = "service-mode-disable"
    ActServiceModeStatus  = "service-mode-status"
)
```

### Структуры

#### Определение структур
```go
// ✅ Хорошо - четкие имена полей, JSON теги на русском для 1С интеграции
type Store struct {
    Name    string `json:"Имя хранилища,omitempty"`
    Path    string `json:"Относительный путь"`
    User    string `json:"Пользователь"`
    Pass    string `json:"Пароль"`
    Command string `json:"-"`
}
```

#### Memory Alignment
```go
// ✅ Хорошо - поля упорядочены по размеру для оптимизации памяти
type OptimizedStruct struct {
    // 8-байтовые поля
    Timestamp time.Time
    
    // 4-байтовые поля
    ID      int32
    Count   int32
    
    // 1-байтовые поля
    Enabled bool
    Active  bool
}
```

### Комментарии Go Doc

#### Пакеты
```go
// Package store предоставляет функциональность для работы с хранилищем конфигураций 1С
package store
```

#### Экспортируемые функции
```go
// EnableServiceMode включает сервисный режим для указанной информационной базы.
// Устанавливает блокировку сессий и регламентных заданий с заданным сообщением.
// Параметры:
//   - ctx: контекст выполнения операции
//   - clusterUUID: уникальный идентификатор кластера
//   - infobaseUUID: уникальный идентификатор информационной базы
//   - terminateSessions: флаг принудительного завершения активных сессий
// Возвращает:
//   - error: ошибка выполнения операции или nil при успехе
func (c *Client) EnableServiceMode(ctx context.Context, clusterUUID, infobaseUUID string, terminateSessions bool) error {
    // Реализация...
}
```

#### Структуры
```go
// ServiceModeStatus представляет статус сервисного режима
type ServiceModeStatus struct {
    Enabled        bool
    Message        string
    ActiveSessions int
}
```

### Обработка ошибок

#### Возврат ошибок с контекстом
```go
// ✅ Хорошо - обертывание ошибок с контекстом
if err != nil {
    return fmt.Errorf("failed to create store %s: %w", storeName, err)
}

// ❌ Плохо - возврат ошибки без контекста
if err != nil {
    return err
}
```

#### Специализированные типы ошибок
```go
// ConfigError представляет ошибку конфигурации
type ConfigError struct {
    Field   string
    Value   string
    Message string
}

func (e *ConfigError) Error() string {
    return fmt.Sprintf("config error in field %s (value: %s): %s", e.Field, e.Value, e.Message)
}
```

## Система сборки (Makefile)

### Основные команды

#### Разработка
```bash
# Сборка проекта
make build

# Сборка для разных платформ
make build-all
make build-linux
make build-windows
make build-darwin

# Установка
make install

# Запуск
make run
```

#### Тестирование
```bash
# Запуск всех тестов
make test

# Тесты с покрытием
make test-coverage

# SMB модуль тесты
make test-smb

# Интеграционные тесты
make test-integration
```

#### Качество кода
```bash
# Форматирование кода
make fmt

# Go vet проверки
make vet

# Линтинг
make lint

# Полная проверка
make check
```

#### Очистка
```bash
# Очистка build артефактов
make clean

# Полная очистка включая зависимости
make clean-all
```

### Добавление новых команд

Для добавления новой команды в Makefile:

```makefile
## new-command: Описание новой команды
new-command:
	@echo "Выполнение новой команды..."
	@# Команды для выполнения
```

## Тестирование

### Структура тестов

#### Unit тесты
```go
// filename_test.go
package mypackage

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestMyFunction(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected string
        wantErr  bool
    }{
        {
            name:     "valid input",
            input:    "test",
            expected: "TEST",
            wantErr:  false,
        },
        {
            name:     "empty input",
            input:    "",
            expected: "",
            wantErr:  true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := MyFunction(tt.input)
            
            if tt.wantErr {
                require.Error(t, err)
                return
            }
            
            require.NoError(t, err)
            assert.Equal(t, tt.expected, result)
        })
    }
}
```

#### Моки и заглушки
```go
// Использование интерфейсов для создания моков
type MockRACClient struct {
    enableServiceModeFunc func(ctx context.Context, clusterUUID, infobaseUUID string, terminateSessions bool) error
}

func (m *MockRACClient) EnableServiceMode(ctx context.Context, clusterUUID, infobaseUUID string, terminateSessions bool) error {
    if m.enableServiceModeFunc != nil {
        return m.enableServiceModeFunc(ctx, clusterUUID, infobaseUUID, terminateSessions)
    }
    return nil
}

func TestServiceModeWithMock(t *testing.T) {
    mockRAC := &MockRACClient{
        enableServiceModeFunc: func(ctx context.Context, clusterUUID, infobaseUUID string, terminateSessions bool) error {
            assert.Equal(t, "test-cluster", clusterUUID)
            assert.Equal(t, "test-infobase", infobaseUUID)
            assert.True(t, terminateSessions)
            return nil
        },
    }
    
    client := NewServiceModeClient(mockRAC, config, logger)
    err := client.EnableServiceMode(context.Background(), "test-infobase", true)
    require.NoError(t, err)
}
```

#### Интеграционные тесты
```go
// +build integration

package integration

import (
    "testing"
    "context"
    "os"
)

func TestGit2StoreIntegration(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test in short mode")
    }
    
    // Проверка наличия переменных окружения для тестов
    gitURL := os.Getenv("TEST_GIT_URL")
    if gitURL == "" {
        t.Skip("TEST_GIT_URL not set, skipping integration test")
    }
    
    ctx := context.Background()
    
    // Реальный тест интеграции
    err := runGit2StoreTest(ctx, gitURL)
    require.NoError(t, err)
}
```

### Покрытие тестами

#### Цели покрытия
- **Unit тесты**: минимум 80% покрытия
- **Интеграционные тесты**: покрытие основных сценариев
- **E2E тесты**: покрытие критических пользовательских сценариев

#### Проверка покрытия
```bash
# Генерация отчета о покрытии
make test-coverage

# Просмотр HTML отчета
go tool cover -html=coverage.out -o coverage.html
open coverage.html
```

#### Исключения из покрытия
```go
// Исключение функций из покрытия (когда оправдано)
//go:build !coverage
// +build !coverage

func debugFunction() {
    // Функция только для отладки
}
```

### Бенчмарки

```go
func BenchmarkMyFunction(b *testing.B) {
    input := "test data"
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        MyFunction(input)
    }
}

func BenchmarkMyFunctionParallel(b *testing.B) {
    input := "test data"
    
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            MyFunction(input)
        }
    })
}
```

### Тестовые данные

#### Фиксированные тестовые данные
```go
var testStoreRecord = StoreRecord{
    Version:     1,
    ConfVersion: "1.0.0.1",
    User:        "TestUser",
    Date:        time.Date(2024, 8, 26, 10, 0, 0, 0, time.UTC),
    Comment:     "Test comment",
}

var testUsers = []User{
    {StoreUserName: "admin", GitUserName: "admin"},
    {StoreUserName: "developer", GitUserName: "dev"},
}
```

#### Генерация тестовых данных
```go
func generateTestConfig() *config.Config {
    return &config.Config{
        AppConfig: &config.AppConfig{
            LogLevel: "Debug",
            WorkDir:  "/tmp/test",
            TmpDir:   "/tmp/test/temp",
            Paths: struct {
                Bin1cv8  string `yaml:"bin1cv8"`
                BinIbcmd string `yaml:"binIbcmd"`
                EdtCli   string `yaml:"edtCli"`
                Rac      string `yaml:"rac"`
            }{
                Bin1cv8:  "/opt/1cv8/test/1cv8",
                BinIbcmd: "/opt/1cv8/test/ibcmd",
                Rac:      "/opt/1cv8/test/rac",
            },
        },
    }
}
```

## CI/CD Integration

### GitHub Actions / Gitea Actions

```yaml
# .gitea/workflows/test.yml
name: Test and Build

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.24.3
        
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
          
    - name: Install dependencies
      run: go mod download
      
    - name: Run tests
      run: make test-coverage
      
    - name: Run lint
      run: make lint
      
    - name: Build
      run: make build-all
      
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
```

### Pre-commit хуки

```bash
#!/bin/sh
# .git/hooks/pre-commit

echo "Running pre-commit checks..."

# Форматирование кода
make fmt

# Проверка ветирования
make vet

# Линтинг
make lint

# Быстрые тесты
make test

if [ $? -ne 0 ]; then
    echo "Pre-commit checks failed!"
    exit 1
fi

echo "Pre-commit checks passed!"
```

## Отладка

### Настройка отладчика

#### VS Code
```json
// .vscode/launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug benadis-runner",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "${workspaceFolder}/cmd/benadis-runner",
            "env": {
                "BR_COMMAND": "convert",
                "BR_LOG_LEVEL": "Debug"
            },
            "args": []
        }
    ]
}
```

#### GoLand
1. Создать новую конфигурацию запуска
2. Тип: Go Build
3. Пакет: `./cmd/benadis-runner`
4. Переменные окружения: `BR_COMMAND=convert;BR_LOG_LEVEL=Debug`

### Логирование для отладки

```go
import (
    "log/slog"
    "os"
)

// Создание отладочного логгера
func createDebugLogger() *slog.Logger {
    opts := &slog.HandlerOptions{
        Level: slog.LevelDebug,
    }
    handler := slog.NewTextHandler(os.Stdout, opts)
    return slog.New(handler)
}

// Отладочная функция
func debugOperation(l *slog.Logger, operation string) {
    l.Debug("Starting operation",
        "operation", operation,
        "timestamp", time.Now(),
        "caller", "debugOperation")
}
```

### Профилирование

#### CPU профилирование
```go
import (
    _ "net/http/pprof"
    "net/http"
)

func main() {
    // Запуск pprof сервера в отдельной горутине
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // Основная логика приложения
    // ...
}
```

#### Анализ производительности
```bash
# CPU профилирование
go tool pprof http://localhost:6060/debug/pprof/profile

# Память
go tool pprof http://localhost:6060/debug/pprof/heap

# Горутины
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

## Процесс разработки

### Git Workflow

#### Ветки
- **main** — стабильная продуктивная версия
- **develop** — основная ветка разработки
- **feature/feature-name** — ветки для новых функций
- **hotfix/issue-number** — срочные исправления
- **release/version** — подготовка релизов

#### Коммиты
```bash
# Хорошие примеры коммитов
git commit -m "feat: add service mode status command"
git commit -m "fix: resolve RAC connection timeout issue"
git commit -m "docs: update API documentation"
git commit -m "test: add unit tests for store operations"
git commit -m "refactor: improve error handling in convert module"

# Формат: <type>: <description>
# Типы: feat, fix, docs, style, refactor, test, chore
```

### Code Review

#### Чек-лист для ревьюера
- [ ] Код следует соглашениям проекта
- [ ] Присутствуют unit тесты для новой функциональности
- [ ] Go Doc комментарии для экспортируемых функций
- [ ] Обработка ошибок с контекстом
- [ ] Нет дублирования кода
- [ ] Производительность не ухудшена
- [ ] Обратная совместимость сохранена

#### Чек-лист для автора
- [ ] Все тесты проходят
- [ ] Линтер не выдает ошибок
- [ ] Документация обновлена
- [ ] CHANGELOG.md обновлен (если нужно)
- [ ] Миграции БД проверены (если применимо)

### Релизы

#### Подготовка релиза
```bash
# Создание ветки релиза
git checkout develop
git pull origin develop
git checkout -b release/v1.2.0

# Обновление версии
echo "v1.2.0" > VERSION

# Финализация релиза
git add VERSION CHANGELOG.md
git commit -m "chore: prepare release v1.2.0"
git checkout main
git merge release/v1.2.0
git tag v1.2.0
git push origin main --tags
```

#### Семантическое версионирование
- **MAJOR** (1.0.0) — breaking changes
- **MINOR** (0.1.0) — новая функциональность, обратно совместимая
- **PATCH** (0.0.1) — исправления ошибок

## Troubleshooting

### Распространенные проблемы разработки

#### "Go модуль не найден"
```bash
# Решение
go mod tidy
go mod download
```

#### "golangci-lint не найден"
```bash
# Установка через дополнительный скрипт
./scripts/inst-golangci-lint-v2.sh

# Или установка через основной скрипт
./scripts/inst-golangci-lint.sh
```

Примечание: После установки убедитесь, что путь к golangci-lint добавлен в переменную окружения PATH.

#### "Тесты не проходят локально"
```bash
# Проверка переменных окружения
export BR_LOG_LEVEL="Debug"
export TEST_MODE="true"

# Запуск с подробным выводом
go test -v ./...
```

#### "Ошибки линтера"
```bash
# Автоматическое исправление
golangci-lint run --fix

# Проверка конкретного файла
golangci-lint run path/to/file.go
```

### Полезные команды

```bash
# Поиск TODO и FIXME
grep -r "TODO\|FIXME" --include="*.go" .

# Проверка зависимостей на уязвимости
govulncheck ./...

# Анализ размера бинарника
go tool nm benadis-runner | wc -l

# Проверка неиспользуемых зависимостей
go mod tidy && git diff go.mod
```

---

*Версия документа: 1.0*  
*Последнее обновление: 2025-08-26*