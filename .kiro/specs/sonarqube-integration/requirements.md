# Requirements Document

## Introduction

Данный документ описывает требования для реализации интеграции с SonarQube в проекте apk-ci. Интеграция должна обеспечить полный цикл работы с анализом качества кода: создание проектов, сканирование веток и pull request'ов, синхронизацию репозиториев, генерацию отчетов и управление жизненным циклом проектов в SonarQube.

## Requirements

### Requirement 1

**User Story:** Как разработчик, я хочу сканировать ветки репозитория в SonarQube, чтобы анализировать качество кода в конкретной ветке

#### Acceptance Criteria

1. WHEN пользователь выполняет команду sq-scan-branch с параметрами owner, repo, branch и опциональным commit_hash THEN система SHALL получить данные о ветке из Gitea API
2. IF ветка не является main THEN система SHALL получить первый коммит ветки для определения базовой точки сканирования
3. WHEN система получает данные о проекте из SonarQube API THEN IF проект не существует THEN система SHALL создать новый проект в SonarQube
4. IF commit_hash не передан AND ветка является main THEN система SHALL сканировать последний коммит ветки
5. IF commit_hash не передан AND ветка не является main THEN система SHALL проверить наличие сканирования базового коммита и при необходимости выполнить сканирование базового и текущего коммитов
6. IF commit_hash передан THEN система SHALL сканировать состояние репозитория на указанный коммит

### Requirement 2

**User Story:** Как разработчик, я хочу сканировать pull request'ы в SonarQube, чтобы анализировать качество кода в изменениях

#### Acceptance Criteria

1. WHEN пользователь выполняет команду sq-scan-pr с параметрами owner, repo, pr THEN система SHALL получить данные PR из Gitea API
2. WHEN система получает данные PR THEN система SHALL извлечь имя ветки источника, первый коммит и последний коммит
3. WHEN система определяет ветку источника THEN система SHALL вызвать sq-scan-branch с пустым commit_hash для сканирования ветки

### Requirement 3

**User Story:** Как администратор проекта, я хочу обновлять метаданные проекта в SonarQube, чтобы поддерживать актуальную информацию о проекте

#### Acceptance Criteria

1. WHEN пользователь выполняет команду sq-project-update с параметрами owner, repo THEN система SHALL получить содержимое README.md из репозитория
2. WHEN система получает содержимое README.md THEN система SHALL обновить описание проекта в SonarQube
3. WHEN система обновляет проект THEN система SHALL синхронизировать список администраторов с группами owners и dev из репозитория owner/repo Gitea

### Requirement 4

**User Story:** Как администратор репозитория, я хочу синхронизировать все ветки репозитория с проектами SonarQube, чтобы обеспечить полное покрытие анализом

#### Acceptance Criteria

1. WHEN пользователь выполняет команду sq-repo-sync с параметрами owner, repo THEN система SHALL получить список веток из Gitea API
2. WHEN система получает список веток THEN система SHALL получить список проектов из SonarQube API
3. FOR каждой ветки IF проект существует THEN система SHALL вызвать sq-project-update ELSE система SHALL вызвать sq-scan-branch с пустым commit_hash
4. WHEN обработка веток завершена THEN система SHALL вызвать sq-repo-clear для очистки устаревших проектов

### Requirement 5

**User Story:** Как администратор системы, я хочу очищать устаревшие проекты в SonarQube, чтобы поддерживать порядок и экономить ресурсы

#### Acceptance Criteria

1. WHEN пользователь выполняет команду sq-repo-clear с параметрами owner, repo, force THEN система SHALL получить значение sq_wait_for_delete из конфигурации
2. WHEN система получает конфигурацию THEN система SHALL получить список веток из Gitea API и список проектов из SonarQube API
3. FOR каждого проекта IF проект не соответствует ни одной ветке THEN IF force равен true THEN система SHALL удалить проект немедленно
4. IF force равен false AND время с последнего сканирования больше sq_wait_for_delete THEN система SHALL удалить проект
5. IF проект не может быть удален THEN система SHALL вывести сообщение о несоответствии

### Requirement 6

**User Story:** Как разработчик, я хочу получать отчеты по pull request'ам, чтобы видеть проблемы качества кода в изменениях

#### Acceptance Criteria

1. WHEN пользователь выполняет команду sq-report-pr с параметрами owner, repo, pr THEN система SHALL получить данные PR из Gitea API
2. WHEN система получает данные PR THEN система SHALL определить ветку источника, первый и последний коммиты
3. WHEN система определяет коммиты THEN система SHALL вызвать sq-report-branch для получения отчета по ветке
4. WHEN система получает отчет по ветке THEN система SHALL сформировать отчет по PR и разместить его в задаче репозитория

### Requirement 7

**User Story:** Как разработчик, я хочу получать отчеты по веткам, чтобы анализировать изменения качества кода между коммитами

#### Acceptance Criteria

1. WHEN пользователь выполняет команду sq-report-branch с параметрами owner, repo, branch, first_commit_hash, last_commit_hash THEN система SHALL получить ошибки между коммитами из SonarQube API
2. WHEN система получает ошибки THEN система SHALL вернуть отчет в формате JSON с детализацией найденных проблем

### Requirement 8

**User Story:** Как менеджер проекта, я хочу получать сводные отчеты по всему проекту, чтобы оценивать общее состояние качества кода

#### Acceptance Criteria

1. WHEN пользователь выполняет команду sq-report-project с параметрами owner, repo THEN система SHALL получить данные о всех ветках из Gitea API
2. FOR каждой ветки IF ветка является main THEN система SHALL получить второй и последний коммиты ELSE система SHALL получить первый и последний коммиты
3. FOR каждой ветки WHEN система определяет коммиты THEN система SHALL вызвать sq-report-branch для получения отчета по ветке
4. WHEN все отчеты получены THEN система SHALL объединить их в сводный отчет по проекту

### Requirement 9

**User Story:** Как системный администратор, я хочу, чтобы система корректно обрабатывала ошибки и предоставляла диагностическую информацию, чтобы быстро решать проблемы

#### Acceptance Criteria

1. WHEN происходит ошибка API SonarQube или Gitea THEN система SHALL логировать детали ошибки и предоставить пользователю понятное сообщение
2. WHEN происходит сетевая ошибка THEN система SHALL повторить запрос согласно политике повторных попыток с экспоненциальной задержкой
3. WHEN конфигурационные файлы отсутствуют или некорректны THEN система SHALL предоставить четкое сообщение об ошибке и корректно завершиться
4. WHEN выполнение sonar-scanner завершается с ошибкой THEN система SHALL захватить вывод ошибки и предоставить детальную диагностическую информацию

### Requirement 10

**User Story:** Как разработчик, я хочу, чтобы система автоматически управляла sonar-scanner, чтобы не заботиться о его установке и настройке

#### Acceptance Criteria

1. WHEN система выполняет сканирование THEN система SHALL скачать sonar-scanner из указанного Gitea репозитория
2. WHEN sonar-scanner скачан THEN система SHALL настроить его с необходимыми параметрами: URL SonarQube, URL репозитория, пути к конфигурации, хеш коммита и ключ проекта
3. WHEN sonar-scanner настроен THEN система SHALL выполнить сканирование и отправить результаты в SonarQube
4. IF загрузка sonar-scanner не удалась AND исчерпаны все попытки повтора THEN система SHALL сообщить об ошибке и завершиться с кодом ошибки

### Requirement 11

**User Story:** Как разработчик, я хочу использовать современные возможности Go, чтобы обеспечить высокое качество и производительность кода

#### Acceptance Criteria

1. THE система SHALL быть реализована с использованием Go версии 1.25 или выше
2. THE система SHALL использовать новые возможности Go 1.25 для улучшения производительности и читаемости кода
3. THE система SHALL использовать современные пакеты стандартной библиотеки Go 1.25
4. THE система SHALL быть совместима с модульной системой Go и использовать go.mod для управления зависимостями

### Requirement 12

**User Story:** Как архитектор системы, я хочу, чтобы код следовал принципам SOLID, чтобы обеспечить maintainability, extensibility и testability

#### Acceptance Criteria

1. THE система SHALL следовать принципу Single Responsibility - каждый класс/структура должна иметь только одну причину для изменения
2. THE система SHALL следовать принципу Open/Closed - компоненты должны быть открыты для расширения, но закрыты для модификации
3. THE система SHALL следовать принципу Liskov Substitution - объекты должны быть заменяемы экземплярами их подтипов без изменения корректности программы
4. THE система SHALL следовать принципу Interface Segregation - клиенты не должны зависеть от интерфейсов, которые они не используют
5. THE система SHALL следовать принципу Dependency Inversion - модули высокого уровня не должны зависеть от модулей низкого уровня, оба должны зависеть от абстракций