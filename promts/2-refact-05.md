- подсистема должна принимать следующие команды:
  - sq-scan-branch <owner> <repo> <branch> <commit_hash>
  - sq-scan-pr <owner> <repo> <pr> <commit_hash>
  - sq-project-update <owner> <repo> <branch>
  - sq-repo-sync <owner> <repo> <force>
  - sq-repo-clear <owner> <repo> <force>
  - sq-report-pr <owner> <repo> <pr>
  - sq-report-branch <owner> <repo> <branch>  <first_commit_hash> <last_commit_hash>
  - sq-report-project <owner> <repo> <first_commit_hash> <last_commit_hash>
Описание функционала команд:
- sq-scan-branch <owner> <repo> <branch> <commit_hash> - сканирование ветки
  - Если <branch>!='main' то получает из gitea API данные по ветке:
    - первый коммит при создании ветки (коммит от которого ветка создана)
  - При запуске получает из SonarQube API данные по проекту с именем <owner>_<repo>_<branch>
  - Если проект не существует, то создается новый проект с именем <owner>_<repo>_<branch>
  - Запускается сканирование проекта с помощью локального sonar-scanner (в сканировании должен быть зафиксирован analysis.commitHash=commit_hash)
  - если <commit_hash> не передан, то:
    - если ветка 'main' то сканируется последний коммит ветки
    - если ветка не 'main' проверяется есть ли сканирование с analysis.commitHash=<коммит от которого создана ветка> затем:
      - если нет то сначала сканируется <коммит от которого создана ветка> затем <текущий коммит> в данной ветке
      - если есть то сканируется <текущий коммит> в данной ветке
  - если <commit_hash> передан, то сканируется состояние репозитория на этот коммит (в сканировании должен быть зафиксирован analysis.commitHash=commit_hash)
- sq-scan-pr <owner> <repo> <pr> - сканирование пул-реквеста
  - Получает из gitea API данные по пул-реквесту:
    - имя ветки источника
  - Запускается sq-scan-branch <owner> <repo> <branch> <commit_hash> с передачей пустого commit_hash
- sq-project-update <owner> <repo> <branch> - обновление проекта
  - Обновляет данные проекта в SonarQube с помощью SonarQube API:
    - описание проекта на основании данных из README.md
    - список администраторов синхронизируется с списком групп репозитория owners и dev
- sq-repo-sync <owner> <repo> <force> - синхронизация репозитория
  - Получает из gitea API список веток репозитория:
  - Получает из SonarQube API список проектов по шаблону <owner>_<repo>_*
  - Для каждой ветки:
    - если проект существует то запускается sq-project-update <owner> <repo> <branch>
    - если проект не существует то запускается sq-scan-branch <owner> <repo> <branch> <commit_hash> с передачей пустого commit_hash
  - Запускается sq-repo-clear <owner> <repo> <force> с передачей полученных на вход параметров
- sq-repo-clear <owner> <repo> <force> - очистка репозитория
  - Из файла app.yaml получаем <sq_wait_for_delete> - время в секундах, которое должно пройти после последнего сканирования проекта, чтобы он был удален
  - Получает из gitea API список веток репозитория <owner> <repo>. Если список пустой то удаляются все проекты <owner>_<repo>_*
  - Получает из SonarQube API список проектов по шаблону <owner>_<repo>_*
  - Для каждого проекта:
    - если проекту не соответствует ветка (в репозитории нет ветки с именем <branch> из имени проекта <owner>_<repo>_<branch>) то:
      - если <force>='true' то запускается sq-project-delete <имя проекта>
      - если <force>!='true' то проверяется время последнего сканирования проекта:
        - если проект сканировался более чем <sq_wait_for_delete> назад то запускается sq-project-delete <имя проекта>
        - если проект сканировался менее <sq_wait_for_delete> назад то выводится сообщение о том что проект не соответствует ветке
- sq-report-pr <owner> <repo> <pr> - отчет по пул-реквесту
  - Получает из gitea API данные по пул-реквесту:
    - имя ветки источника
    - первый коммит при создании ветки (коммит от которого ветка создана)
    - последний коммит в пул-реквесте
  - Запускает sq-report-branch <owner> <repo> <branch> <first_commit_hash> <last_commit_hash> с передачей полученных на вход параметров
  - Используя полученный отчет по ветке, формирует отчет по пул-реквесту и размещает его в задаче репозитория <owner> <repo>:
    - Заголовок "Ревью пул-реквеста <pr>"
    - Содержание отчета по пул-реквесту:
      - имя ветки источника
      - первый коммит при создании ветки (коммит от которого ветка создана)
      - последний коммит в пул-реквесте
      - список ошибок по типам
        - список ошибок
          - имя файла
          - строка
          - сообщение
      - Формат комментария к задаче - markdown
- sq-report-branch <owner> <repo> <branch> <first_commit_hash> <last_commit_hash> - отчет по ветке
  - Используя SonarQube API получает ошибки добавленные между сканированием <first_commit_hash> и <last_commit_hash> для проекта <owner>_<repo>_<branch>
  - Возвращает отчет в формате json с полями:
    - имя ветки источника
    - первый коммит при создании ветки (коммит от которого ветка создана)
    - последний коммит в пул-реквесте
    - список ошибок по типам
      - список ошибок
        - имя файла
        - строка
        - сообщение
- sq-report-project <owner> <repo> <first_commit_hash> <last_commit_hash> - отчет по проекту
  - Получает из gitea API данные по веткам репозитория:
    - имя ветки источника
    - если ветка 'main' то:
      - второй коммит в ветку
      - последний коммит в ветке
    - если ветка не 'main' то:
      - первый коммит при создании ветки (коммит от которого ветка создана)
      - последний коммит в ветке
  - Запускает sq-report-branch <owner> <repo> <branch> <first_commit_hash> <last_commit_hash> для каждой ветки
