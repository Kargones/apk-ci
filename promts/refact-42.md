Проанализируйте текущий проект и составьте подробный документ SRS (Software Requirements Specification), который полностью отражает существующий функционал. Документ должен содержать:

1. Детальное описание всех функций системы
2. Требования к интерфейсам и взаимодействию компонентов
3. Бизнес-правила и логику работы системы
4. Ограничения и условия работы
5. Требования к производительности и безопасности

Документ должен быть достаточно полным и четким, чтобы на его основе можно было:
- Разработать документ архитектуры проекта
- Реализовать программное обеспечение, полностью воспроизводящее текущий функционал проекта


Используйте шаблоны EARS для структурирования требований к ПО, группируя их по User Stories. Разделяйте требования на категории в соответствии с типами EARS: Ubiquitous, Event-driven, Unwanted Behavior, State-driven, Optional Features и Complex. Для каждой категории используйте ключевые слова на русском языке ПРОПИСНЫМИ БУКВАМИ, за которыми следует шаблон и описание требования на русском языке и критерии приемки.
При формулировке требований:

Добавляйте идентификаторы (например, REQ-001) для traceability.
Указывайте критерии приемки (например, тесты или метрики).
Обеспечьте однозначность, избегая неоднозначных терминов.
Для комплексных требований комбинируйте шаблоны, но разбивайте на атомарные элементы, если возможно.
Интегрируйте архитектурные аспекты: описывайте компоненты системы, интерфейсы, данные и взаимодействия.
Используйте следующие шаблоны:
```markdown
Ubiquitous (Повсеместные требования):

Шаблон: "The <system> shall <function>."</function></system>
Описание: Для требований, которые всегда активны, без условий или событий. Это базовый шаблон для простых функциональных требований.
Пример: "The authentication system shall verify user credentials within 2 seconds."
Когда использовать: Для постоянных функций системы.


Event-driven (Событийные требования):

Шаблон: "When <event>, the <system> shall <function>."</function></system></event>
Описание: Требования, активируемые внешним событием или триггером.
Пример: "When a user submits a form, the database shall store the data securely."
Когда использовать: Для реакций на события, такие как нажатие кнопки или получение сообщения.


Unwanted Behavior (Требования к нежелательному поведению):

Шаблон: "If <condition>, then the <system> shall <function>."</function></system></condition>
Описание: Для обработки ошибок, исключений или нежелательных ситуаций.
Пример: "If the network connection is lost, then the application shall retry the request up to 3 times."
Когда использовать: Для сценариев восстановления или предотвращения сбоев.


State-driven (Состоянийные требования):

Шаблон: "While <state>, the <system> shall <function>."</function></system></state>
Описание: Требования, действующие в определённом состоянии системы.
Пример: "While in manufacturing mode, the software shall boot without user intervention."
Когда использовать: Для систем с несколькими состояниями, такими как "режим обслуживания" или "режим ожидания".


Optional Features (Опциональные требования):

Шаблон: "Where <feature>, the <system> shall <function>."</function></system></feature>
Описание: Для требований, зависящих от наличия опциональной функции или конфигурации.
Пример: "Where high availability is enabled, the system shall replicate data across nodes."
Когда использовать: Для конфигурируемых функций или вариантов системы.


Complex (Комплексные требования):

Шаблон: Комбинация вышеуказанных (например, "While <state>, if <condition>, then when <event>, the <system> shall <function>.").</function></system></event></condition></state>
Описание: Для сложных сценариев, где сочетаются несколько шаблонов.
Пример: "While in emergency mode, if battery is low, then when alert is triggered, the system shall send notification."
Когда использовать: Когда простые шаблоны недостаточны, но старайтесь избегать чрезмерной сложности — лучше разбить на несколько требований.
```
Выделяйте ключевые слова шаблона ПРОПИСНЫМИ БУКВАМИ.
Генерируйте SRS как полный документ с разделами: Введение, User Stories, Требования по категориям EARS, Архитектурные аспекты (компоненты, интерфейсы), Критерии приемки.