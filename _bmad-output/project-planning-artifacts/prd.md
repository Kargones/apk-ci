# benadis-runner - Product Requirements Document

**Author:** XoR
**Date:** 2025-11-25
**Version:** 1.1

---

## Executive Summary

benadis-runner v2.0 — это трансформация существующего CLI-инструмента автоматизации для 1C:Enterprise из механического объединения утилит в расширяемую платформу с plug-in архитектурой.

**Проблема**: Текущая версия нарушает принципы SOLID, что приводит к высоким затратам на добавление нового функционала. Одинаковые операции выполняются по-разному в разных частях кода.

**Решение**: Поэтапный рефакторинг с созданием модульной архитектуры, где все реализации скрыты за интерфейсами, а выбор конкретной реализации (1cv8/ibcmd/собственная утилита) определяется конфигурацией.

**Целевая аудитория**: DevOps-инженеры, 1C-разработчики, системные аналитики, тестировщики и служба поддержки.

### What Makes This Special

**Платформа, а не утилита** — возможность добавлять новый функционал с минимальными издержками, используя существующие сервисы и данные (доступ к коду решений, тестовым и продуктивным базам). Например:
- Анализ логов пользователей для выявления узких мест — нужно реализовать только аналитику
- AI-анализ кода — нужно реализовать только подсистему AI
- Новые интеграции — plug-in архитектура позволяет подключать их без изменения ядра

---

## Project Classification

**Technical Type:** cli_tool
**Domain:** general
**Complexity:** low

Проект относится к категории DevOps/CI-CD инструментов без специфических регуляторных требований. Основная сложность — в качественном рефакторинге существующего кода с сохранением обратной совместимости.

---

## Stakeholders

| Роль | Потребности | Приоритет |
|------|-------------|-----------|
| **DevOps-инженеры** | Автоматизация CI/CD пайплайнов, надёжные команды с понятными ошибками, интеграция с существующими инструментами | Высокий |
| **1C-разработчики** | Быстрая синхронизация EDT↔хранилище, создание тестовых баз, выполнение EPF | Высокий |
| **Системные аналитики** | Отчёты о качестве кода, метрики по проектам, анализ изменений | Средний |
| **Тестировщики** | Создание тестовых окружений, восстановление баз из production | Средний |
| **Служба поддержки** | Диагностика проблем по логам, понятные сообщения об ошибках | Средний |
| **Технический лид** | Архитектурная чистота, расширяемость, соответствие SOLID | Высокий |

---

## Success Criteria

### Технический успех

1. **Архитектурная чистота**: Все SOLID нарушения из `docs/architecture/solid-violations.md` устранены, новые не появляются
2. **Расширяемость**: Новый функционал добавляется через создание нового модуля без изменения существующего кода (Open/Closed Principle)
3. **Взаимозаменяемость реализаций**: Любая операция (например, выгрузка конфигурации) может выполняться через 1cv8, ibcmd или собственную утилиту — выбор через конфигурацию
4. **Полная миграция**: Все 17 команд работают на новой архитектуре, старый код удалён

### Операционный успех

1. **Сохранение функциональности**: После каждого этапа рефакторинга все существующие команды работают идентично
2. **Observability**: Проблемы диагностируются по логам/трейсам без подключения к production-системам
3. **Время диагностики**: Поиск причины ошибки занимает минуты, а не часы

### Пользовательский успех

1. **Простота миграции**: Переход на новые команды (NR-префикс) требует только изменения имени команды в скриптах
2. **Структурированный вывод**: Результаты в JSON/YAML формате легко интегрируются с другими инструментами

### Быстрые wins

1. **Первая NR-команда в production**: До завершения Фазы 1 — подтверждение что архитектура работает
2. **Видимый прогресс**: Каждую неделю — измеримое улучшение (кол-во NR-команд, test coverage, удалённый deprecated-код)

### Definition of Done по фазам

**Фаза 1 (Архитектурный фундамент)**: DI-контейнер работает, первая команда (service-mode-status) реализована на новой архитектуре и используется в production-пайплайне

**Фаза 2 (Миграция команд)**: Все 17 NR-команд проходят тесты и используются минимум в 3 production-пайплайнах

**Фаза 3 (Observability)**: Логи, трейсы и алерты работают в production, проблема диагностируется без доступа к серверу

**Фаза 4 (Финализация)**: Deprecated-код удалён, все пайплайны используют финальные команды

### Gate-критерий

Переход к следующей фазе возможен только после выполнения DoD текущей фазы. Если 3 NR-команды не используются в production-пайплайнах в течение разумного времени — пересмотр scope.

---

## Risk Management

### Критические риски и митигации

**R1: Затягивание рефакторинга**
- Gate: Минимум 3 NR-команды должны быть в production до начала массовой миграции
- Эскалация: При существенном отставании от плана → scope cut

**R2: NR ломает production**
- Shadow-run обязателен для всех команд перед production
- Canary deployment на некритичных пайплайнах
- Rollback: Мгновенное переключение на старую команду

### Мониторинг рисков

Регулярный review:
- Кол-во NR-команд в production
- Test coverage
- Кол-во инцидентов из-за NR-команд

---

## Product Scope

### MVP - Minimum Viable Product

**Фаза 1: Архитектурный фундамент** (приоритет)
- SOLID-совместимая архитектура с чётким разделением по модулям
- Все реализации скрыты за интерфейсами
- Dependency Injection контейнер
- Структурированный вывод (JSON/YAML) для интеграции

**Фаза 2: Миграция команд**
- Все 17 команд реализованы на новой архитектуре (NR-префикс)
- Старые команды помечены @deprecated
- Тесты покрывают обе реализации

**Фаза 3: Observability**
- Логирование в файлы с ротацией (JSON формат)
- Алертинг (email, Telegram, webhook, Prometheus/Alertmanager)
- OpenTelemetry трассировка
- Delve отладка (Linux/Docker)

**Фаза 4: Финализация**
- Удаление старого кода (@deprecated)
- Переименование NR-команд в основные
- Обновление документации

### Growth Features (Post-MVP)

- **Web Interface**: Web UI для интерактивной работы на машине разработчика (выполнение команд, просмотр результатов, дашборды)
- **AI-анализ кода**: Интеграция с LLM для code review и рекомендаций
- **Анализ пользовательских логов**: Выявление узких мест в учётных системах
- **Расширенная аналитика**: Дашборды метрик по проектам
- **Plugin-система**: Полноценная plugin-архитектура с registry и lifecycle (если потребность подтвердится)
- **Multi-tenant режим**: Работа с несколькими организациями
- **История операций с откатом**: Возможность отменить последнюю операцию (для разработчиков)
- **Агрегированные отчёты**: Сводные отчёты по качеству кода для нескольких проектов (для аналитиков)
- **Шаблоны тестовых баз**: Быстрое создание типовых тестовых окружений (для тестировщиков)

### Vision (Future)

- **Полная платформа 1C DevOps**: Единая точка управления всем жизненным циклом 1C-решений
- **Предиктивная аналитика**: Предупреждение о потенциальных проблемах до их возникновения
- **Self-service портал**: Пользователи сами выполняют типовые операции через UI
- **Интеграция с IDE**: Плагины для VS Code и 1C:EDT

---

## cli_tool Specific Requirements

### Структура команд

**Текущая структура** (сохраняется для обратной совместимости):
```
BR_COMMAND=<command-name> ./benadis-runner
```

**Новая структура** (NR-версии во время миграции):
```
BR_COMMAND=nr-<command-name> ./benadis-runner
```

**Финальная структура** (после удаления deprecated):
```
BR_COMMAND=<command-name> ./benadis-runner
```

### Форматы вывода

| Формат | Назначение | Флаг/Env |
|--------|------------|----------|
| Text | Человекочитаемый вывод (по умолчанию) | `BR_OUTPUT_FORMAT=text` |
| JSON | Интеграция с системами автоматизации | `BR_OUTPUT_FORMAT=json` |
| YAML | Конфигурационные данные | `BR_OUTPUT_FORMAT=yaml` |

Структура JSON-вывода:
```json
{
  "status": "success|error",
  "command": "command-name",
  "data": { ... },
  "error": { "code": "...", "message": "..." },
  "metadata": { "duration_ms": 1234, "trace_id": "..." }
}
```

### Схема конфигурации

**Приоритет источников** (от высшего к низшему):
1. Переменные окружения (`BR_*`, `DBRESTORE_*`, etc.)
2. Локальный файл конфигурации (`~/.benadis-runner/config.yaml`)
3. Проектный файл (`./benadis-runner.yaml`)
4. Удалённые файлы из Gitea API
5. Значения по умолчанию

**Новые секции конфигурации**:
```yaml
# Выбор реализаций
implementations:
  config_export: "ibcmd"  # 1cv8 | ibcmd | native
  db_create: "1cv8"       # 1cv8 | ibcmd

# Observability
logging:
  file: "/var/log/benadis-runner/app.log"
  format: "json"
  rotation:
    max_size_mb: 100
    max_files: 10

tracing:
  enabled: true
  endpoint: "http://jaeger:4318"

alerting:
  channels:
    - type: "telegram"
      token: "${TELEGRAM_BOT_TOKEN}"
      chat_id: "${TELEGRAM_CHAT_ID}"
    - type: "email"
      smtp_host: "smtp.example.com"
```

### Поддержка скриптов

- **Exit codes**: Стандартизированные коды возврата для всех команд
- **Stdin**: Поддержка pipe для входных данных
- **Stdout/Stderr**: Чёткое разделение (данные → stdout, логи → stderr)
- **Сигналы**: Корректная обработка SIGTERM/SIGINT для graceful shutdown

---

## Архитектурные принципы

Эти принципы — guard rails для всех архитектурных решений:

1. **Minimal Interface Principle**: Интерфейсы содержат только необходимые методы. Широкий интерфейс → разбить на role-based интерфейсы.

2. **Package Single Responsibility**: Каждый пакет имеет одну причину для изменения. `internal/app` — только оркестрация, не бизнес-логика и не инфраструктура.

3. **Dependency Inversion Everywhere**: Все внешние зависимости (Gitea, SonarQube, 1C, MSSQL) доступны только через интерфейсы. Конкретные реализации — в DI-провайдерах.

4. **Explicit Over Implicit**: Зависимости передаются явно через конструкторы, не создаются внутри функций.

5. **ADR Before Implementation**: Значимые архитектурные решения документируются в Architecture Decision Records до реализации.

---

## External Dependencies

| Зависимость | Версия | Назначение | Критичность |
|-------------|--------|------------|-------------|
| **1C:Enterprise Platform** | 8.3.20+ | Основная платформа для всех операций с ИБ | Критическая |
| **1cv8** | 8.3.20+ | CLI для Designer-операций (создание БД, выгрузка конфигураций) | Критическая |
| **ibcmd** | 8.3.20+ | CLI для операций с информационными базами | Высокая |
| **rac** | 8.3.20+ | Консоль администрирования кластера 1C | Высокая |
| **1cedtcli (1C EDT CLI)** | 2025+ | Автоматизация EDT для процессов разработки | Средняя |
| **Gitea** | 1.24+ | Хранение конфигурации, API для интеграции | Критическая |
| **MSSQL Server** | 2019+ | Хранение баз данных 1C | Критическая |
| **SonarQube** | 9.x+ | Анализ качества кода | Средняя |
| **OpenTelemetry Collector** | — | Сбор трейсов (Jaeger/Tempo) | Низкая (опционально) |

---

## Assumptions

1. **Инфраструктура 1C доступна**: Сервер 1C и кластер настроены и доступны по сети
2. **Права доступа**: У сервисного аккаунта есть права на все операции с базами и хранилищами
3. **Gitea API**: Репозиторий конфигурации доступен через API с валидным токеном
4. **MSSQL**: Сервер БД доступен, права на выполнение скрипта restore предоставлены
5. **Сетевая связность**: Все внешние сервисы (Gitea, SonarQube, MSSQL) доступны из среды выполнения
6. **Один инстанс**: Приложение запускается как единичный процесс (не требуется распределённая координация)
7. **CI/CD окружение**: Основной сценарий использования — запуск в Gitea Actions

---

## Модель выполнения операций

### Принцип State-Aware Execution

Каждая операция начинается с проверки текущего состояния инфраструктуры. Система строит план действий на основе разницы между текущим и желаемым состоянием.

### Принцип Automatic Dependencies

Если операция требует prerequisite (например, dbupdate требует сервисный режим), система выполняет их автоматически и откатывает после завершения.

### Принцип Idempotency

Повторный вызов операции с теми же параметрами безопасен и приводит к тому же результату. "Включить сервисный режим" когда он уже включён — не ошибка, а подтверждение состояния.

---

## Functional Requirements

### Архитектура и сменные реализации

- FR1: Система поддерживает регистрацию реализаций операций через strategy-интерфейсы
- FR2: Выбор конкретной реализации операции определяется конфигурацией
- FR3: Новые реализации добавляются без изменения существующего кода
- FR4: Все зависимости внедряются через DI-контейнер
- FR5: Модули имеют чёткие границы и взаимодействуют только через интерфейсы

### Управление сервисным режимом

- FR6: Оператор может включить сервисный режим для информационной базы
- FR7: Оператор может отключить сервисный режим
- FR8: Оператор может проверить текущий статус сервисного режима
- FR9: Система поддерживает принудительное завершение сессий пользователей

### Операции с базами данных

- FR10: Оператор может восстановить базу данных MSSQL из резервной копии
- FR11: Система автоматически рассчитывает таймаут на основе размера бэкапа
- FR12: Оператор может обновить структуру базы данных по конфигурации
- FR13: Оператор может создать временную локальную базу данных с расширениями

### Синхронизация конфигурации

- FR14: Оператор может загрузить конфигурацию из хранилища 1C в базу данных
- FR15: Оператор может привязать хранилище конфигурации к базе данных
- FR16: Система синхронизирует формат EDT из Git в хранилище 1C
- FR17: Оператор может инициализировать хранилища для проекта и расширений
- FR18: Система поддерживает выбор инструмента для операций с конфигурацией (1cv8/ibcmd/native)

### Конвертация форматов

- FR19: Система конвертирует между форматами EDT и XML
- FR20: Оператор может выбрать инструмент конвертации через конфигурацию

### Выполнение внешних обработок

- FR21: Оператор может выполнить внешнюю обработку (.epf) в 1C Enterprise

### SonarQube интеграция

- FR22: Система сканирует коммиты ветки с фильтрацией по шаблону
- FR23: Система сканирует pull request
- FR24: Система обновляет метаданные проекта в SonarQube
- FR25: Система генерирует отчёт о качестве для ветки, проверяя новые ошибки между коммитом от которого создана ветка и последним коммитом в ветке

### Gitea интеграция

- FR26: Система проверяет конфликты слияния для всех открытых PR
- FR27: Система строит динамическое меню действий из конфигурации
- FR28: Система загружает конфигурацию из репозитория Gitea

### Вывод и форматирование

- FR29: Система выводит результаты в форматах text/JSON/YAML
- FR30: Формат вывода определяется конфигурацией или параметром
- FR31: Данные выводятся в stdout, логи в stderr

### Логирование

- FR32: Система записывает логи в файлы с ротацией
- FR33: Логи записываются в JSON формате для автоматизированного анализа
- FR34: Уровень логирования настраивается через конфигурацию
- FR35: Каждая запись содержит trace_id для корреляции

### Алертинг

- FR36: Система отправляет алерты на email
- FR37: Система отправляет алерты в Telegram
- FR38: Система отправляет алерты через webhook
- FR39: Система экспортирует метрики для Prometheus/Alertmanager
- FR40: Правила алертинга настраиваются через конфигурацию

### Трассировка

- FR41: Система отправляет трейсы в OpenTelemetry-совместимый бэкенд
- FR42: Каждая операция имеет уникальный trace_id
- FR43: Трейсы включают span-ы для ключевых этапов операции

### Отладка

- FR44: Приложение может запускаться в режиме отладки с Delve
- FR45: Поддерживается удалённое подключение к отладчику
- FR46: Отладка работает на Linux (включая Docker)

### Миграция и совместимость

- FR47: Новые команды имеют префикс NR во время миграции
- FR48: Старые команды помечаются @deprecated но продолжают работать
- FR49: После полной миграции deprecated-код удаляется
- FR50: Система логирует использование deprecated-команд с рекомендацией миграции

### Валидация и тестирование миграции

- FR51: Режим shadow-run позволяет выполнять новую команду параллельно со старой и сравнивать результаты
- FR52: Автоматические smoke-тесты выполняются на реальных конфигурациях 1C после каждого merge
- FR53: Sampling rate для трейсов настраивается через конфигурацию
- FR54: Отправка логов и трейсов выполняется асинхронно с буферизацией

### Архитектурное управление

- FR55: Все значимые архитектурные решения документируются в ADR перед реализацией
- FR56: Code review включает проверку соответствия архитектурным принципам

### Дополнительные возможности для стейкхолдеров

- FR57: Система экспортирует метрики в формате Prometheus для Grafana дашбордов
- FR58: Команды поддерживают dry-run режим для проверки без выполнения действий
- FR59: При восстановлении БД из production можно применить маскирование персональных данных (опционально)

### Модель выполнения операций

- FR60: Система проверяет текущее состояние инфраструктуры перед выполнением операции
- FR61: Система может автоматически выполнять prerequisite-операции (флаг --auto-deps, по умолчанию выключено)
- FR62: Операции управления состоянием (сервисный режим, статусы) идемпотентны — повторный вызов безопасен
- FR63: Система показывает план операций перед выполнением (в verbose режиме)

### Миграция и rollback

- FR64: Система поддерживает мгновенный rollback с NR-команды на старую версию (< 5 минут)
- FR65: Скрипт автоматической миграции пайплайнов на NR-команды

### User Experience

- FR66: Команда service-mode-status показывает количество активных сессий и их владельцев
- FR67: Долгие операции (> 30 сек) показывают progress bar с оценкой оставшегося времени
- FR68: Каждая команда выводит summary с ключевыми метриками по завершении

---

## Non-Functional Requirements

### Performance

- NFR1: Время старта приложения не превышает 500ms
- NFR2: Overhead от observability (логи, трейсы) не превышает 5% времени операции

### Security

- NFR3: Конфиденциальные данные (токены, пароли) не попадают в логи
- NFR4: Конфиденциальные данные передаются только через переменные окружения или защищённые файлы
- NFR5: API endpoints (если добавятся) доступны только на localhost по умолчанию

### Scalability

- NFR6: Архитектура поддерживает параллельное выполнение независимых операций
- NFR7: Логи и трейсы не блокируют основной поток выполнения

### Maintainability

- NFR8: Покрытие кода тестами не менее 80%
- NFR9: Cyclomatic complexity функций не превышает 10
- NFR10: Все публичные интерфейсы документированы
- NFR11: Код проходит golangci-lint без ошибок

### Compatibility

- NFR12: Поддержка Go 1.25+
- NFR13: Работа на Linux (Ubuntu 20.04+, Docker)
- NFR14: Совместимость с 1C:Enterprise 8.3.20+

### Simplicity

- NFR15: Типовая команда (без внешних интеграций) реализуется максимум в 3 файлах

### CI/CD

- NFR16: Deprecated-код автоматически обнаруживается CI-проверками перед Фазой 4

### Testing & Migration

- NFR17: Перед рефакторингом любой функции для неё должны быть написаны тесты
- NFR18: Deprecated-код удаляется после достаточного периода использования NR-замены в production

---

_This PRD captures the essence of benadis-runner — трансформация из набора утилит в расширяемую платформу для 1C DevOps с современным observability стеком и возможностью быстрого добавления нового функционала._
